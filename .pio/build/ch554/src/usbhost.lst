                                      1 ;--------------------------------------------------------
                                      2 ; File Created by SDCC : free open source ISO C Compiler 
                                      3 ; Version 4.4.0 #14620 (MINGW32)
                                      4 ;--------------------------------------------------------
                                      5 	.module usbhost
                                      6 	.optsdcc -mmcs51 --model-small
                                      7 	
                                      8 ;--------------------------------------------------------
                                      9 ; Public variables in this module
                                     10 ;--------------------------------------------------------
                                     11 	.globl _mDelaymS
                                     12 	.globl _mDelayuS
                                     13 	.globl _memset
                                     14 	.globl _UIF_BUS_RST
                                     15 	.globl _UIF_DETECT
                                     16 	.globl _UIF_TRANSFER
                                     17 	.globl _UIF_SUSPEND
                                     18 	.globl _UIF_HST_SOF
                                     19 	.globl _UIF_FIFO_OV
                                     20 	.globl _U_SIE_FREE
                                     21 	.globl _U_TOG_OK
                                     22 	.globl _U_IS_NAK
                                     23 	.globl _ADC_CHAN0
                                     24 	.globl _ADC_CHAN1
                                     25 	.globl _CMP_CHAN
                                     26 	.globl _ADC_START
                                     27 	.globl _ADC_IF
                                     28 	.globl _CMP_IF
                                     29 	.globl _CMPO
                                     30 	.globl _U1RI
                                     31 	.globl _U1TI
                                     32 	.globl _U1RB8
                                     33 	.globl _U1TB8
                                     34 	.globl _U1REN
                                     35 	.globl _U1SMOD
                                     36 	.globl _U1SM0
                                     37 	.globl _S0_R_FIFO
                                     38 	.globl _S0_T_FIFO
                                     39 	.globl _S0_FREE
                                     40 	.globl _S0_IF_BYTE
                                     41 	.globl _S0_IF_FIRST
                                     42 	.globl _S0_IF_OV
                                     43 	.globl _S0_FST_ACT
                                     44 	.globl _CP_RL2
                                     45 	.globl _C_T2
                                     46 	.globl _TR2
                                     47 	.globl _EXEN2
                                     48 	.globl _TCLK
                                     49 	.globl _RCLK
                                     50 	.globl _EXF2
                                     51 	.globl _CAP1F
                                     52 	.globl _TF2
                                     53 	.globl _RI
                                     54 	.globl _TI
                                     55 	.globl _RB8
                                     56 	.globl _TB8
                                     57 	.globl _REN
                                     58 	.globl _SM2
                                     59 	.globl _SM1
                                     60 	.globl _SM0
                                     61 	.globl _IT0
                                     62 	.globl _IE0
                                     63 	.globl _IT1
                                     64 	.globl _IE1
                                     65 	.globl _TR0
                                     66 	.globl _TF0
                                     67 	.globl _TR1
                                     68 	.globl _TF1
                                     69 	.globl _RXD
                                     70 	.globl _PWM1_
                                     71 	.globl _TXD
                                     72 	.globl _PWM2_
                                     73 	.globl _AIN3
                                     74 	.globl _VBUS1
                                     75 	.globl _INT0
                                     76 	.globl _TXD1_
                                     77 	.globl _INT1
                                     78 	.globl _T0
                                     79 	.globl _RXD1_
                                     80 	.globl _PWM2
                                     81 	.globl _T1
                                     82 	.globl _UDP
                                     83 	.globl _UDM
                                     84 	.globl _TIN0
                                     85 	.globl _CAP1
                                     86 	.globl _T2
                                     87 	.globl _AIN0
                                     88 	.globl _VBUS2
                                     89 	.globl _TIN1
                                     90 	.globl _CAP2
                                     91 	.globl _T2EX
                                     92 	.globl _RXD_
                                     93 	.globl _TXD_
                                     94 	.globl _AIN1
                                     95 	.globl _UCC1
                                     96 	.globl _TIN2
                                     97 	.globl _SCS
                                     98 	.globl _CAP1_
                                     99 	.globl _T2_
                                    100 	.globl _AIN2
                                    101 	.globl _UCC2
                                    102 	.globl _TIN3
                                    103 	.globl _PWM1
                                    104 	.globl _MOSI
                                    105 	.globl _TIN4
                                    106 	.globl _RXD1
                                    107 	.globl _MISO
                                    108 	.globl _TIN5
                                    109 	.globl _TXD1
                                    110 	.globl _SCK
                                    111 	.globl _IE_SPI0
                                    112 	.globl _IE_TKEY
                                    113 	.globl _IE_USB
                                    114 	.globl _IE_ADC
                                    115 	.globl _IE_UART1
                                    116 	.globl _IE_PWMX
                                    117 	.globl _IE_GPIO
                                    118 	.globl _IE_WDOG
                                    119 	.globl _PX0
                                    120 	.globl _PT0
                                    121 	.globl _PX1
                                    122 	.globl _PT1
                                    123 	.globl _PS
                                    124 	.globl _PT2
                                    125 	.globl _PL_FLAG
                                    126 	.globl _PH_FLAG
                                    127 	.globl _EX0
                                    128 	.globl _ET0
                                    129 	.globl _EX1
                                    130 	.globl _ET1
                                    131 	.globl _ES
                                    132 	.globl _ET2
                                    133 	.globl _E_DIS
                                    134 	.globl _EA
                                    135 	.globl _P
                                    136 	.globl _F1
                                    137 	.globl _OV
                                    138 	.globl _RS0
                                    139 	.globl _RS1
                                    140 	.globl _F0
                                    141 	.globl _AC
                                    142 	.globl _CY
                                    143 	.globl _UEP1_DMA_H
                                    144 	.globl _UEP1_DMA_L
                                    145 	.globl _UEP1_DMA
                                    146 	.globl _UEP0_DMA_H
                                    147 	.globl _UEP0_DMA_L
                                    148 	.globl _UEP0_DMA
                                    149 	.globl _UEP2_3_MOD
                                    150 	.globl _UEP4_1_MOD
                                    151 	.globl _UEP3_DMA_H
                                    152 	.globl _UEP3_DMA_L
                                    153 	.globl _UEP3_DMA
                                    154 	.globl _UEP2_DMA_H
                                    155 	.globl _UEP2_DMA_L
                                    156 	.globl _UEP2_DMA
                                    157 	.globl _USB_DEV_AD
                                    158 	.globl _USB_CTRL
                                    159 	.globl _USB_INT_EN
                                    160 	.globl _UEP4_T_LEN
                                    161 	.globl _UEP4_CTRL
                                    162 	.globl _UEP0_T_LEN
                                    163 	.globl _UEP0_CTRL
                                    164 	.globl _USB_RX_LEN
                                    165 	.globl _USB_MIS_ST
                                    166 	.globl _USB_INT_ST
                                    167 	.globl _USB_INT_FG
                                    168 	.globl _UEP3_T_LEN
                                    169 	.globl _UEP3_CTRL
                                    170 	.globl _UEP2_T_LEN
                                    171 	.globl _UEP2_CTRL
                                    172 	.globl _UEP1_T_LEN
                                    173 	.globl _UEP1_CTRL
                                    174 	.globl _UDEV_CTRL
                                    175 	.globl _USB_C_CTRL
                                    176 	.globl _TKEY_DATH
                                    177 	.globl _TKEY_DATL
                                    178 	.globl _TKEY_DAT
                                    179 	.globl _TKEY_CTRL
                                    180 	.globl _ADC_DATA
                                    181 	.globl _ADC_CFG
                                    182 	.globl _ADC_CTRL
                                    183 	.globl _SBAUD1
                                    184 	.globl _SBUF1
                                    185 	.globl _SCON1
                                    186 	.globl _SPI0_SETUP
                                    187 	.globl _SPI0_CK_SE
                                    188 	.globl _SPI0_CTRL
                                    189 	.globl _SPI0_DATA
                                    190 	.globl _SPI0_STAT
                                    191 	.globl _PWM_CK_SE
                                    192 	.globl _PWM_CTRL
                                    193 	.globl _PWM_DATA1
                                    194 	.globl _PWM_DATA2
                                    195 	.globl _T2CAP1H
                                    196 	.globl _T2CAP1L
                                    197 	.globl _T2CAP1
                                    198 	.globl _TH2
                                    199 	.globl _TL2
                                    200 	.globl _T2COUNT
                                    201 	.globl _RCAP2H
                                    202 	.globl _RCAP2L
                                    203 	.globl _RCAP2
                                    204 	.globl _T2MOD
                                    205 	.globl _T2CON
                                    206 	.globl _SBUF
                                    207 	.globl _SCON
                                    208 	.globl _TH1
                                    209 	.globl _TH0
                                    210 	.globl _TL1
                                    211 	.globl _TL0
                                    212 	.globl _TMOD
                                    213 	.globl _TCON
                                    214 	.globl _XBUS_AUX
                                    215 	.globl _PIN_FUNC
                                    216 	.globl _P3_DIR_PU
                                    217 	.globl _P3_MOD_OC
                                    218 	.globl _P3
                                    219 	.globl _P2
                                    220 	.globl _P1_DIR_PU
                                    221 	.globl _P1_MOD_OC
                                    222 	.globl _P1
                                    223 	.globl _ROM_CTRL
                                    224 	.globl _ROM_DATA_H
                                    225 	.globl _ROM_DATA_L
                                    226 	.globl _ROM_DATA
                                    227 	.globl _ROM_ADDR_H
                                    228 	.globl _ROM_ADDR_L
                                    229 	.globl _ROM_ADDR
                                    230 	.globl _GPIO_IE
                                    231 	.globl _IP_EX
                                    232 	.globl _IE_EX
                                    233 	.globl _IP
                                    234 	.globl _IE
                                    235 	.globl _WDOG_COUNT
                                    236 	.globl _RESET_KEEP
                                    237 	.globl _WAKE_CTRL
                                    238 	.globl _CLOCK_CFG
                                    239 	.globl _PCON
                                    240 	.globl _GLOBAL_CFG
                                    241 	.globl _SAFE_MOD
                                    242 	.globl _DPH
                                    243 	.globl _DPL
                                    244 	.globl _SP
                                    245 	.globl _B
                                    246 	.globl _ACC
                                    247 	.globl _PSW
                                    248 	.globl _HostCtrlTransfer_PARM_2
                                    249 	.globl _USBHostTransact_PARM_3
                                    250 	.globl _USBHostTransact_PARM_2
                                    251 	.globl _DisableRootHubPort
                                    252 	.globl _AnalyzeRootHub
                                    253 	.globl _SetHostUsbAddr
                                    254 	.globl _SetUsbSpeed
                                    255 	.globl _ResetRootHubPort
                                    256 	.globl _EnableRootHubPort
                                    257 	.globl _SelectHubPort
                                    258 	.globl _WaitUSB_Interrupt
                                    259 	.globl _USBHostTransact
                                    260 	.globl _HostCtrlTransfer
                                    261 	.globl _CopySetupReqPkg
                                    262 	.globl _CtrlGetDeviceDescr
                                    263 	.globl _CtrlGetConfigDescr
                                    264 	.globl _CtrlSetUsbAddress
                                    265 	.globl _CtrlSetUsbConfig
                                    266 	.globl _CtrlClearEndpStall
                                    267 	.globl _CtrlSetUsbInterface
                                    268 	.globl _CtrlGetHIDDeviceReport
                                    269 	.globl _AnalyzeHidIntEndp
                                    270 	.globl _AnalyzeBulkEndp
                                    271 	.globl _InitRootDevice
                                    272 	.globl _EnumAllRootDevice
                                    273 	.globl _SearchTypeDevice
                                    274 	.globl _SetBootProto
                                    275 	.globl _InitUSB_Host
                                    276 ;--------------------------------------------------------
                                    277 ; special function registers
                                    278 ;--------------------------------------------------------
                                    279 	.area RSEG    (ABS,DATA)
      000000                        280 	.org 0x0000
                           0000D0   281 _PSW	=	0x00d0
                           0000E0   282 _ACC	=	0x00e0
                           0000F0   283 _B	=	0x00f0
                           000081   284 _SP	=	0x0081
                           000082   285 _DPL	=	0x0082
                           000083   286 _DPH	=	0x0083
                           0000A1   287 _SAFE_MOD	=	0x00a1
                           0000B1   288 _GLOBAL_CFG	=	0x00b1
                           000087   289 _PCON	=	0x0087
                           0000B9   290 _CLOCK_CFG	=	0x00b9
                           0000A9   291 _WAKE_CTRL	=	0x00a9
                           0000FE   292 _RESET_KEEP	=	0x00fe
                           0000FF   293 _WDOG_COUNT	=	0x00ff
                           0000A8   294 _IE	=	0x00a8
                           0000B8   295 _IP	=	0x00b8
                           0000E8   296 _IE_EX	=	0x00e8
                           0000E9   297 _IP_EX	=	0x00e9
                           0000C7   298 _GPIO_IE	=	0x00c7
                           008584   299 _ROM_ADDR	=	0x8584
                           000084   300 _ROM_ADDR_L	=	0x0084
                           000085   301 _ROM_ADDR_H	=	0x0085
                           008F8E   302 _ROM_DATA	=	0x8f8e
                           00008E   303 _ROM_DATA_L	=	0x008e
                           00008F   304 _ROM_DATA_H	=	0x008f
                           000086   305 _ROM_CTRL	=	0x0086
                           000090   306 _P1	=	0x0090
                           000092   307 _P1_MOD_OC	=	0x0092
                           000093   308 _P1_DIR_PU	=	0x0093
                           0000A0   309 _P2	=	0x00a0
                           0000B0   310 _P3	=	0x00b0
                           000096   311 _P3_MOD_OC	=	0x0096
                           000097   312 _P3_DIR_PU	=	0x0097
                           0000C6   313 _PIN_FUNC	=	0x00c6
                           0000A2   314 _XBUS_AUX	=	0x00a2
                           000088   315 _TCON	=	0x0088
                           000089   316 _TMOD	=	0x0089
                           00008A   317 _TL0	=	0x008a
                           00008B   318 _TL1	=	0x008b
                           00008C   319 _TH0	=	0x008c
                           00008D   320 _TH1	=	0x008d
                           000098   321 _SCON	=	0x0098
                           000099   322 _SBUF	=	0x0099
                           0000C8   323 _T2CON	=	0x00c8
                           0000C9   324 _T2MOD	=	0x00c9
                           00CBCA   325 _RCAP2	=	0xcbca
                           0000CA   326 _RCAP2L	=	0x00ca
                           0000CB   327 _RCAP2H	=	0x00cb
                           00CDCC   328 _T2COUNT	=	0xcdcc
                           0000CC   329 _TL2	=	0x00cc
                           0000CD   330 _TH2	=	0x00cd
                           00CFCE   331 _T2CAP1	=	0xcfce
                           0000CE   332 _T2CAP1L	=	0x00ce
                           0000CF   333 _T2CAP1H	=	0x00cf
                           00009B   334 _PWM_DATA2	=	0x009b
                           00009C   335 _PWM_DATA1	=	0x009c
                           00009D   336 _PWM_CTRL	=	0x009d
                           00009E   337 _PWM_CK_SE	=	0x009e
                           0000F8   338 _SPI0_STAT	=	0x00f8
                           0000F9   339 _SPI0_DATA	=	0x00f9
                           0000FA   340 _SPI0_CTRL	=	0x00fa
                           0000FB   341 _SPI0_CK_SE	=	0x00fb
                           0000FC   342 _SPI0_SETUP	=	0x00fc
                           0000C0   343 _SCON1	=	0x00c0
                           0000C1   344 _SBUF1	=	0x00c1
                           0000C2   345 _SBAUD1	=	0x00c2
                           000080   346 _ADC_CTRL	=	0x0080
                           00009A   347 _ADC_CFG	=	0x009a
                           00009F   348 _ADC_DATA	=	0x009f
                           0000C3   349 _TKEY_CTRL	=	0x00c3
                           00C5C4   350 _TKEY_DAT	=	0xc5c4
                           0000C4   351 _TKEY_DATL	=	0x00c4
                           0000C5   352 _TKEY_DATH	=	0x00c5
                           000091   353 _USB_C_CTRL	=	0x0091
                           0000D1   354 _UDEV_CTRL	=	0x00d1
                           0000D2   355 _UEP1_CTRL	=	0x00d2
                           0000D3   356 _UEP1_T_LEN	=	0x00d3
                           0000D4   357 _UEP2_CTRL	=	0x00d4
                           0000D5   358 _UEP2_T_LEN	=	0x00d5
                           0000D6   359 _UEP3_CTRL	=	0x00d6
                           0000D7   360 _UEP3_T_LEN	=	0x00d7
                           0000D8   361 _USB_INT_FG	=	0x00d8
                           0000D9   362 _USB_INT_ST	=	0x00d9
                           0000DA   363 _USB_MIS_ST	=	0x00da
                           0000DB   364 _USB_RX_LEN	=	0x00db
                           0000DC   365 _UEP0_CTRL	=	0x00dc
                           0000DD   366 _UEP0_T_LEN	=	0x00dd
                           0000DE   367 _UEP4_CTRL	=	0x00de
                           0000DF   368 _UEP4_T_LEN	=	0x00df
                           0000E1   369 _USB_INT_EN	=	0x00e1
                           0000E2   370 _USB_CTRL	=	0x00e2
                           0000E3   371 _USB_DEV_AD	=	0x00e3
                           00E5E4   372 _UEP2_DMA	=	0xe5e4
                           0000E4   373 _UEP2_DMA_L	=	0x00e4
                           0000E5   374 _UEP2_DMA_H	=	0x00e5
                           00E7E6   375 _UEP3_DMA	=	0xe7e6
                           0000E6   376 _UEP3_DMA_L	=	0x00e6
                           0000E7   377 _UEP3_DMA_H	=	0x00e7
                           0000EA   378 _UEP4_1_MOD	=	0x00ea
                           0000EB   379 _UEP2_3_MOD	=	0x00eb
                           00EDEC   380 _UEP0_DMA	=	0xedec
                           0000EC   381 _UEP0_DMA_L	=	0x00ec
                           0000ED   382 _UEP0_DMA_H	=	0x00ed
                           00EFEE   383 _UEP1_DMA	=	0xefee
                           0000EE   384 _UEP1_DMA_L	=	0x00ee
                           0000EF   385 _UEP1_DMA_H	=	0x00ef
                                    386 ;--------------------------------------------------------
                                    387 ; special function bits
                                    388 ;--------------------------------------------------------
                                    389 	.area RSEG    (ABS,DATA)
      000000                        390 	.org 0x0000
                           0000D7   391 _CY	=	0x00d7
                           0000D6   392 _AC	=	0x00d6
                           0000D5   393 _F0	=	0x00d5
                           0000D4   394 _RS1	=	0x00d4
                           0000D3   395 _RS0	=	0x00d3
                           0000D2   396 _OV	=	0x00d2
                           0000D1   397 _F1	=	0x00d1
                           0000D0   398 _P	=	0x00d0
                           0000AF   399 _EA	=	0x00af
                           0000AE   400 _E_DIS	=	0x00ae
                           0000AD   401 _ET2	=	0x00ad
                           0000AC   402 _ES	=	0x00ac
                           0000AB   403 _ET1	=	0x00ab
                           0000AA   404 _EX1	=	0x00aa
                           0000A9   405 _ET0	=	0x00a9
                           0000A8   406 _EX0	=	0x00a8
                           0000BF   407 _PH_FLAG	=	0x00bf
                           0000BE   408 _PL_FLAG	=	0x00be
                           0000BD   409 _PT2	=	0x00bd
                           0000BC   410 _PS	=	0x00bc
                           0000BB   411 _PT1	=	0x00bb
                           0000BA   412 _PX1	=	0x00ba
                           0000B9   413 _PT0	=	0x00b9
                           0000B8   414 _PX0	=	0x00b8
                           0000EF   415 _IE_WDOG	=	0x00ef
                           0000EE   416 _IE_GPIO	=	0x00ee
                           0000ED   417 _IE_PWMX	=	0x00ed
                           0000EC   418 _IE_UART1	=	0x00ec
                           0000EB   419 _IE_ADC	=	0x00eb
                           0000EA   420 _IE_USB	=	0x00ea
                           0000E9   421 _IE_TKEY	=	0x00e9
                           0000E8   422 _IE_SPI0	=	0x00e8
                           000097   423 _SCK	=	0x0097
                           000097   424 _TXD1	=	0x0097
                           000097   425 _TIN5	=	0x0097
                           000096   426 _MISO	=	0x0096
                           000096   427 _RXD1	=	0x0096
                           000096   428 _TIN4	=	0x0096
                           000095   429 _MOSI	=	0x0095
                           000095   430 _PWM1	=	0x0095
                           000095   431 _TIN3	=	0x0095
                           000095   432 _UCC2	=	0x0095
                           000095   433 _AIN2	=	0x0095
                           000094   434 _T2_	=	0x0094
                           000094   435 _CAP1_	=	0x0094
                           000094   436 _SCS	=	0x0094
                           000094   437 _TIN2	=	0x0094
                           000094   438 _UCC1	=	0x0094
                           000094   439 _AIN1	=	0x0094
                           000093   440 _TXD_	=	0x0093
                           000092   441 _RXD_	=	0x0092
                           000091   442 _T2EX	=	0x0091
                           000091   443 _CAP2	=	0x0091
                           000091   444 _TIN1	=	0x0091
                           000091   445 _VBUS2	=	0x0091
                           000091   446 _AIN0	=	0x0091
                           000090   447 _T2	=	0x0090
                           000090   448 _CAP1	=	0x0090
                           000090   449 _TIN0	=	0x0090
                           0000B7   450 _UDM	=	0x00b7
                           0000B6   451 _UDP	=	0x00b6
                           0000B5   452 _T1	=	0x00b5
                           0000B4   453 _PWM2	=	0x00b4
                           0000B4   454 _RXD1_	=	0x00b4
                           0000B4   455 _T0	=	0x00b4
                           0000B3   456 _INT1	=	0x00b3
                           0000B2   457 _TXD1_	=	0x00b2
                           0000B2   458 _INT0	=	0x00b2
                           0000B2   459 _VBUS1	=	0x00b2
                           0000B2   460 _AIN3	=	0x00b2
                           0000B1   461 _PWM2_	=	0x00b1
                           0000B1   462 _TXD	=	0x00b1
                           0000B0   463 _PWM1_	=	0x00b0
                           0000B0   464 _RXD	=	0x00b0
                           00008F   465 _TF1	=	0x008f
                           00008E   466 _TR1	=	0x008e
                           00008D   467 _TF0	=	0x008d
                           00008C   468 _TR0	=	0x008c
                           00008B   469 _IE1	=	0x008b
                           00008A   470 _IT1	=	0x008a
                           000089   471 _IE0	=	0x0089
                           000088   472 _IT0	=	0x0088
                           00009F   473 _SM0	=	0x009f
                           00009E   474 _SM1	=	0x009e
                           00009D   475 _SM2	=	0x009d
                           00009C   476 _REN	=	0x009c
                           00009B   477 _TB8	=	0x009b
                           00009A   478 _RB8	=	0x009a
                           000099   479 _TI	=	0x0099
                           000098   480 _RI	=	0x0098
                           0000CF   481 _TF2	=	0x00cf
                           0000CF   482 _CAP1F	=	0x00cf
                           0000CE   483 _EXF2	=	0x00ce
                           0000CD   484 _RCLK	=	0x00cd
                           0000CC   485 _TCLK	=	0x00cc
                           0000CB   486 _EXEN2	=	0x00cb
                           0000CA   487 _TR2	=	0x00ca
                           0000C9   488 _C_T2	=	0x00c9
                           0000C8   489 _CP_RL2	=	0x00c8
                           0000FF   490 _S0_FST_ACT	=	0x00ff
                           0000FE   491 _S0_IF_OV	=	0x00fe
                           0000FD   492 _S0_IF_FIRST	=	0x00fd
                           0000FC   493 _S0_IF_BYTE	=	0x00fc
                           0000FB   494 _S0_FREE	=	0x00fb
                           0000FA   495 _S0_T_FIFO	=	0x00fa
                           0000F8   496 _S0_R_FIFO	=	0x00f8
                           0000C7   497 _U1SM0	=	0x00c7
                           0000C5   498 _U1SMOD	=	0x00c5
                           0000C4   499 _U1REN	=	0x00c4
                           0000C3   500 _U1TB8	=	0x00c3
                           0000C2   501 _U1RB8	=	0x00c2
                           0000C1   502 _U1TI	=	0x00c1
                           0000C0   503 _U1RI	=	0x00c0
                           000087   504 _CMPO	=	0x0087
                           000086   505 _CMP_IF	=	0x0086
                           000085   506 _ADC_IF	=	0x0085
                           000084   507 _ADC_START	=	0x0084
                           000083   508 _CMP_CHAN	=	0x0083
                           000081   509 _ADC_CHAN1	=	0x0081
                           000080   510 _ADC_CHAN0	=	0x0080
                           0000DF   511 _U_IS_NAK	=	0x00df
                           0000DE   512 _U_TOG_OK	=	0x00de
                           0000DD   513 _U_SIE_FREE	=	0x00dd
                           0000DC   514 _UIF_FIFO_OV	=	0x00dc
                           0000DB   515 _UIF_HST_SOF	=	0x00db
                           0000DA   516 _UIF_SUSPEND	=	0x00da
                           0000D9   517 _UIF_TRANSFER	=	0x00d9
                           0000D8   518 _UIF_DETECT	=	0x00d8
                           0000D8   519 _UIF_BUS_RST	=	0x00d8
                                    520 ;--------------------------------------------------------
                                    521 ; overlayable register banks
                                    522 ;--------------------------------------------------------
                                    523 	.area REG_BANK_0	(REL,OVR,DATA)
      000000                        524 	.ds 8
                                    525 ;--------------------------------------------------------
                                    526 ; internal ram data
                                    527 ;--------------------------------------------------------
                                    528 	.area DSEG    (DATA)
      000000                        529 _USBHostTransact_PARM_2:
      000000                        530 	.ds 1
      000001                        531 _USBHostTransact_PARM_3:
      000001                        532 	.ds 2
      000003                        533 _USBHostTransact_endp_pid_10000_117:
      000003                        534 	.ds 1
      000004                        535 _USBHostTransact_TransRetry_10000_118:
      000004                        536 	.ds 1
      000005                        537 _HostCtrlTransfer_PARM_2:
      000005                        538 	.ds 3
      000008                        539 _HostCtrlTransfer_RxLen_10000_128:
      000008                        540 	.ds 1
      000009                        541 _HostCtrlTransfer_pBuf_10000_128:
      000009                        542 	.ds 2
      00000B                        543 _HostCtrlTransfer_pLen_10000_128:
      00000B                        544 	.ds 3
      00000E                        545 _CtrlGetDeviceDescr_len_10000_154:
      00000E                        546 	.ds 1
      00000F                        547 _CtrlGetConfigDescr_len_10000_158:
      00000F                        548 	.ds 1
      000010                        549 _CtrlGetHIDDeviceReport_len_10000_171:
      000010                        550 	.ds 1
      000011                        551 _AnalyzeBulkEndp_buf_10000_180:
      000011                        552 	.ds 2
      000013                        553 _AnalyzeBulkEndp_s1_10000_181:
      000013                        554 	.ds 1
      000014                        555 _AnalyzeBulkEndp_s2_10000_181:
      000014                        556 	.ds 1
      000015                        557 _SetBootProto_get_10000_220:
      000015                        558 	.ds 8
      00001D                        559 _SetBootProto_set_10000_220:
      00001D                        560 	.ds 8
      000025                        561 _SetBootProto_report_10000_220:
      000025                        562 	.ds 8
      00002D                        563 _SetBootProto_len_10000_220:
      00002D                        564 	.ds 1
                                    565 ;--------------------------------------------------------
                                    566 ; overlayable items in internal ram
                                    567 ;--------------------------------------------------------
                                    568 	.area	OSEG    (OVR,DATA)
                                    569 	.area	OSEG    (OVR,DATA)
                                    570 	.area	OSEG    (OVR,DATA)
                                    571 	.area	OSEG    (OVR,DATA)
                                    572 	.area	OSEG    (OVR,DATA)
                                    573 ;--------------------------------------------------------
                                    574 ; indirectly addressable internal ram data
                                    575 ;--------------------------------------------------------
                                    576 	.area ISEG    (DATA)
                                    577 ;--------------------------------------------------------
                                    578 ; absolute internal ram data
                                    579 ;--------------------------------------------------------
                                    580 	.area IABS    (ABS,DATA)
                                    581 	.area IABS    (ABS,DATA)
                                    582 ;--------------------------------------------------------
                                    583 ; bit data
                                    584 ;--------------------------------------------------------
                                    585 	.area BSEG    (BIT)
      000000                        586 _HostCtrlTransfer_sloc0_1_0:
      000000                        587 	.ds 1
                                    588 ;--------------------------------------------------------
                                    589 ; paged external ram data
                                    590 ;--------------------------------------------------------
                                    591 	.area PSEG    (PAG,XDATA)
                                    592 ;--------------------------------------------------------
                                    593 ; uninitialized external ram data
                                    594 ;--------------------------------------------------------
                                    595 	.area XSEG    (XDATA)
                                    596 ;--------------------------------------------------------
                                    597 ; absolute external ram data
                                    598 ;--------------------------------------------------------
                                    599 	.area XABS    (ABS,XDATA)
                                    600 ;--------------------------------------------------------
                                    601 ; initialized external ram data
                                    602 ;--------------------------------------------------------
                                    603 	.area XISEG   (XDATA)
                                    604 	.area HOME    (CODE)
                                    605 	.area GSINIT0 (CODE)
                                    606 	.area GSINIT1 (CODE)
                                    607 	.area GSINIT2 (CODE)
                                    608 	.area GSINIT3 (CODE)
                                    609 	.area GSINIT4 (CODE)
                                    610 	.area GSINIT5 (CODE)
                                    611 	.area GSINIT  (CODE)
                                    612 	.area GSFINAL (CODE)
                                    613 	.area CSEG    (CODE)
                                    614 ;--------------------------------------------------------
                                    615 ; global & static initialisations
                                    616 ;--------------------------------------------------------
                                    617 	.area HOME    (CODE)
                                    618 	.area GSINIT  (CODE)
                                    619 	.area GSFINAL (CODE)
                                    620 	.area GSINIT  (CODE)
                                    621 ;--------------------------------------------------------
                                    622 ; Home
                                    623 ;--------------------------------------------------------
                                    624 	.area HOME    (CODE)
                                    625 	.area HOME    (CODE)
                                    626 ;--------------------------------------------------------
                                    627 ; code
                                    628 ;--------------------------------------------------------
                                    629 	.area CSEG    (CODE)
                                    630 ;------------------------------------------------------------
                                    631 ;Allocation info for local variables in function 'DisableRootHubPort'
                                    632 ;------------------------------------------------------------
                                    633 ;	src\usbhost.c:28: void DisableRootHubPort(void)
                                    634 ;	-----------------------------------------
                                    635 ;	 function DisableRootHubPort
                                    636 ;	-----------------------------------------
      000000                        637 _DisableRootHubPort:
                           000007   638 	ar7 = 0x07
                           000006   639 	ar6 = 0x06
                           000005   640 	ar5 = 0x05
                           000004   641 	ar4 = 0x04
                           000003   642 	ar3 = 0x03
                           000002   643 	ar2 = 0x02
                           000001   644 	ar1 = 0x01
                           000000   645 	ar0 = 0x00
                                    646 ;	src\usbhost.c:30: ThisUsbDev.DeviceStatus = ROOT_DEV_DISCONNECT;
      000000 90r00r00         [24]  647 	mov	dptr,#_ThisUsbDev
      000003 E4               [12]  648 	clr	a
      000004 F0               [24]  649 	movx	@dptr,a
                                    650 ;	src\usbhost.c:31: ThisUsbDev.DeviceAddress = 0x00;
      000005 90r00r01         [24]  651 	mov	dptr,#(_ThisUsbDev + 0x0001)
      000008 F0               [24]  652 	movx	@dptr,a
                                    653 ;	src\usbhost.c:32: }
      000009 22               [24]  654 	ret
                                    655 ;------------------------------------------------------------
                                    656 ;Allocation info for local variables in function 'AnalyzeRootHub'
                                    657 ;------------------------------------------------------------
                                    658 ;s                         Allocated to registers r7 
                                    659 ;------------------------------------------------------------
                                    660 ;	src\usbhost.c:41: uint8_t AnalyzeRootHub(void)
                                    661 ;	-----------------------------------------
                                    662 ;	 function AnalyzeRootHub
                                    663 ;	-----------------------------------------
      00000A                        664 _AnalyzeRootHub:
                                    665 ;	src\usbhost.c:44: s = ERR_SUCCESS;
      00000A 7F 00            [12]  666 	mov	r7,#0x00
                                    667 ;	src\usbhost.c:45: if (USB_MIS_ST & bUMS_DEV_ATTACH)
      00000C E5 DA            [12]  668 	mov	a,_USB_MIS_ST
      00000E 30 E0 18         [24]  669 	jnb	acc.0,00107$
                                    670 ;	src\usbhost.c:47: if (ThisUsbDev.DeviceStatus == ROOT_DEV_DISCONNECT // Device plugged in
      000011 90r00r00         [24]  671 	mov	dptr,#_ThisUsbDev
      000014 E0               [24]  672 	movx	a,@dptr
      000015 60 05            [24]  673 	jz	00101$
                                    674 ;	src\usbhost.c:48: || (UHOST_CTRL & bUH_PORT_EN) == 0x00)
      000017 E5 D1            [12]  675 	mov	a,_UDEV_CTRL
      000019 20 E0 1C         [24]  676 	jb	acc.0,00108$
      00001C                        677 00101$:
                                    678 ;	src\usbhost.c:50: DisableRootHubPort();                         // Close the port
      00001C 12r00r00         [24]  679 	lcall	_DisableRootHubPort
                                    680 ;	src\usbhost.c:52: ThisUsbDev.DeviceStatus = ROOT_DEV_CONNECTED; // Set the connection flag
      00001F 90r00r00         [24]  681 	mov	dptr,#_ThisUsbDev
      000022 74 01            [12]  682 	mov	a,#0x01
      000024 F0               [24]  683 	movx	@dptr,a
                                    684 ;	src\usbhost.c:56: s = ERR_USB_CONNECT;
      000025 7F 15            [12]  685 	mov	r7,#0x15
      000027 80 0F            [24]  686 	sjmp	00108$
      000029                        687 00107$:
                                    688 ;	src\usbhost.c:59: else if (ThisUsbDev.DeviceStatus >= ROOT_DEV_CONNECTED)
      000029 90r00r00         [24]  689 	mov	dptr,#_ThisUsbDev
      00002C E0               [24]  690 	movx	a,@dptr
      00002D FE               [12]  691 	mov	r6,a
      00002E BE 01 00         [24]  692 	cjne	r6,#0x01,00132$
      000031                        693 00132$:
      000031 40 05            [24]  694 	jc	00108$
                                    695 ;	src\usbhost.c:61: DisableRootHubPort(); // Close the port
      000033 12r00r00         [24]  696 	lcall	_DisableRootHubPort
                                    697 ;	src\usbhost.c:66: s = ERR_USB_DISCON;
      000036 7F 16            [12]  698 	mov	r7,#0x16
      000038                        699 00108$:
                                    700 ;	src\usbhost.c:69: return (s);
      000038 8F 82            [24]  701 	mov	dpl, r7
                                    702 ;	src\usbhost.c:70: }
      00003A 22               [24]  703 	ret
                                    704 ;------------------------------------------------------------
                                    705 ;Allocation info for local variables in function 'SetHostUsbAddr'
                                    706 ;------------------------------------------------------------
                                    707 ;addr                      Allocated to registers r7 
                                    708 ;------------------------------------------------------------
                                    709 ;	src\usbhost.c:78: void SetHostUsbAddr(uint8_t addr)
                                    710 ;	-----------------------------------------
                                    711 ;	 function SetHostUsbAddr
                                    712 ;	-----------------------------------------
      00003B                        713 _SetHostUsbAddr:
      00003B AF 82            [24]  714 	mov	r7, dpl
                                    715 ;	src\usbhost.c:80: USB_DEV_AD = USB_DEV_AD & bUDA_GP_BIT | addr & 0x7F;
      00003D E5 E3            [12]  716 	mov	a,_USB_DEV_AD
      00003F 54 80            [12]  717 	anl	a,#0x80
      000041 FE               [12]  718 	mov	r6,a
      000042 74 7F            [12]  719 	mov	a,#0x7f
      000044 5F               [12]  720 	anl	a,r7
      000045 4E               [12]  721 	orl	a,r6
      000046 F5 E3            [12]  722 	mov	_USB_DEV_AD,a
                                    723 ;	src\usbhost.c:81: }
      000048 22               [24]  724 	ret
                                    725 ;------------------------------------------------------------
                                    726 ;Allocation info for local variables in function 'SetUsbSpeed'
                                    727 ;------------------------------------------------------------
                                    728 ;FullSpeed                 Allocated to registers r7 
                                    729 ;------------------------------------------------------------
                                    730 ;	src\usbhost.c:90: void SetUsbSpeed(uint8_t FullSpeed)
                                    731 ;	-----------------------------------------
                                    732 ;	 function SetUsbSpeed
                                    733 ;	-----------------------------------------
      000049                        734 _SetUsbSpeed:
                                    735 ;	src\usbhost.c:92: if (FullSpeed) // full speed
      000049 E5 82            [12]  736 	mov	a,dpl
      00004B 60 07            [24]  737 	jz	00102$
                                    738 ;	src\usbhost.c:94: USB_CTRL &= ~bUC_LOW_SPEED;  // full speed
      00004D 53 E2 BF         [24]  739 	anl	_USB_CTRL,#0xbf
                                    740 ;	src\usbhost.c:95: UH_SETUP &= ~bUH_PRE_PID_EN; // Prohibit PRE PID
      000050 53 D2 7F         [24]  741 	anl	_UEP1_CTRL,#0x7f
      000053 22               [24]  742 	ret
      000054                        743 00102$:
                                    744 ;	src\usbhost.c:99: USB_CTRL |= bUC_LOW_SPEED; // Low speed
      000054 43 E2 40         [24]  745 	orl	_USB_CTRL,#0x40
                                    746 ;	src\usbhost.c:101: }
      000057 22               [24]  747 	ret
                                    748 ;------------------------------------------------------------
                                    749 ;Allocation info for local variables in function 'ResetRootHubPort'
                                    750 ;------------------------------------------------------------
                                    751 ;	src\usbhost.c:110: void ResetRootHubPort(void)
                                    752 ;	-----------------------------------------
                                    753 ;	 function ResetRootHubPort
                                    754 ;	-----------------------------------------
      000058                        755 _ResetRootHubPort:
                                    756 ;	src\usbhost.c:112: UsbDevEndp0Size = DEFAULT_ENDP0_SIZE;       // Maximum packet size of endpoint 0 of the USB device
      000058 90r00r00         [24]  757 	mov	dptr,#_UsbDevEndp0Size
      00005B 74 08            [12]  758 	mov	a,#0x08
      00005D F0               [24]  759 	movx	@dptr,a
                                    760 ;	src\usbhost.c:113: memset(&ThisUsbDev, 0, sizeof(ThisUsbDev)); // Empty structure
      00005E 75*00 00         [24]  761 	mov	_memset_PARM_2,#0x00
      000061 75*00 0D         [24]  762 	mov	_memset_PARM_3,#0x0d
      000064 75*01 00         [24]  763 	mov	(_memset_PARM_3 + 1),#0x00
      000067 90r00r00         [24]  764 	mov	dptr,#_ThisUsbDev
      00006A 75 F0 00         [24]  765 	mov	b, #0x00
      00006D 12r00r00         [24]  766 	lcall	_memset
                                    767 ;	src\usbhost.c:114: SetHostUsbAddr(0x00);
      000070 75 82 00         [24]  768 	mov	dpl, #0x00
      000073 12r00r3B         [24]  769 	lcall	_SetHostUsbAddr
                                    770 ;	src\usbhost.c:115: UHOST_CTRL &= ~bUH_PORT_EN;                               // Turn off the port
      000076 53 D1 FE         [24]  771 	anl	_UDEV_CTRL,#0xfe
                                    772 ;	src\usbhost.c:116: SetUsbSpeed(1);                                           // The default is full speed
      000079 75 82 01         [24]  773 	mov	dpl, #0x01
      00007C 12r00r49         [24]  774 	lcall	_SetUsbSpeed
                                    775 ;	src\usbhost.c:117: UHOST_CTRL = UHOST_CTRL & ~bUH_LOW_SPEED | bUH_BUS_RESET; // The default is full speed, start to reset
      00007F 74 FB            [12]  776 	mov	a,#0xfb
      000081 55 D1            [12]  777 	anl	a,_UDEV_CTRL
      000083 44 02            [12]  778 	orl	a,#0x02
      000085 F5 D1            [12]  779 	mov	_UDEV_CTRL,a
                                    780 ;	src\usbhost.c:118: mDelaymS(20);                                             // Reset time 10mS to 20mS
      000087 90 00 14         [24]  781 	mov	dptr,#0x0014
      00008A 12r00r00         [24]  782 	lcall	_mDelaymS
                                    783 ;	src\usbhost.c:119: UHOST_CTRL = UHOST_CTRL & ~bUH_BUS_RESET;                 // End reset
      00008D 53 D1 FD         [24]  784 	anl	_UDEV_CTRL,#0xfd
                                    785 ;	src\usbhost.c:120: mDelayuS(250);
      000090 90 00 FA         [24]  786 	mov	dptr,#0x00fa
      000093 12r00r00         [24]  787 	lcall	_mDelayuS
                                    788 ;	src\usbhost.c:121: UIF_DETECT = 0; // Clear interrupt flag
                                    789 ;	assignBit
      000096 C2 D8            [12]  790 	clr	_UIF_DETECT
                                    791 ;	src\usbhost.c:122: }
      000098 22               [24]  792 	ret
                                    793 ;------------------------------------------------------------
                                    794 ;Allocation info for local variables in function 'EnableRootHubPort'
                                    795 ;------------------------------------------------------------
                                    796 ;	src\usbhost.c:130: uint8_t EnableRootHubPort(void)
                                    797 ;	-----------------------------------------
                                    798 ;	 function EnableRootHubPort
                                    799 ;	-----------------------------------------
      000099                        800 _EnableRootHubPort:
                                    801 ;	src\usbhost.c:132: if (ThisUsbDev.DeviceStatus < ROOT_DEV_CONNECTED)
      000099 90r00r00         [24]  802 	mov	dptr,#_ThisUsbDev
      00009C E0               [24]  803 	movx	a,@dptr
      00009D FF               [12]  804 	mov	r7,a
      00009E BF 01 00         [24]  805 	cjne	r7,#0x01,00143$
      0000A1                        806 00143$:
      0000A1 50 06            [24]  807 	jnc	00102$
                                    808 ;	src\usbhost.c:133: ThisUsbDev.DeviceStatus = ROOT_DEV_CONNECTED;
      0000A3 90r00r00         [24]  809 	mov	dptr,#_ThisUsbDev
      0000A6 74 01            [12]  810 	mov	a,#0x01
      0000A8 F0               [24]  811 	movx	@dptr,a
      0000A9                        812 00102$:
                                    813 ;	src\usbhost.c:134: if (USB_MIS_ST & bUMS_DEV_ATTACH)
      0000A9 E5 DA            [12]  814 	mov	a,_USB_MIS_ST
      0000AB 30 E0 28         [24]  815 	jnb	acc.0,00108$
                                    816 ;	src\usbhost.c:136: if ((UHOST_CTRL & bUH_PORT_EN) == 0x00)
      0000AE E5 D1            [12]  817 	mov	a,_UDEV_CTRL
      0000B0 20 E0 16         [24]  818 	jb	acc.0,00106$
                                    819 ;	src\usbhost.c:138: ThisUsbDev.DeviceSpeed = USB_MIS_ST & bUMS_DM_LEVEL ? 0 : 1;
      0000B3 E5 DA            [12]  820 	mov	a,_USB_MIS_ST
      0000B5 30 E1 04         [24]  821 	jnb	acc.1,00111$
      0000B8 7F 00            [12]  822 	mov	r7,#0x00
      0000BA 80 02            [24]  823 	sjmp	00112$
      0000BC                        824 00111$:
      0000BC 7F 01            [12]  825 	mov	r7,#0x01
      0000BE                        826 00112$:
      0000BE 90r00r02         [24]  827 	mov	dptr,#(_ThisUsbDev + 0x0002)
      0000C1 EF               [12]  828 	mov	a,r7
      0000C2 F0               [24]  829 	movx	@dptr,a
                                    830 ;	src\usbhost.c:139: if (ThisUsbDev.DeviceSpeed == 0)
      0000C3 EF               [12]  831 	mov	a,r7
      0000C4 70 03            [24]  832 	jnz	00106$
                                    833 ;	src\usbhost.c:140: UHOST_CTRL |= bUH_LOW_SPEED; // Low speed
      0000C6 43 D1 04         [24]  834 	orl	_UDEV_CTRL,#0x04
      0000C9                        835 00106$:
                                    836 ;	src\usbhost.c:142: USB_CTRL |= bUC_DMA_EN; // Start the USB host and DMA, and automatically pause before the interrupt flag is cleared
      0000C9 43 E2 01         [24]  837 	orl	_USB_CTRL,#0x01
                                    838 ;	src\usbhost.c:143: UH_SETUP = bUH_SOF_EN;
      0000CC 75 D2 40         [24]  839 	mov	_UEP1_CTRL,#0x40
                                    840 ;	src\usbhost.c:144: UHOST_CTRL |= bUH_PORT_EN; // Enable HUB port
      0000CF 43 D1 01         [24]  841 	orl	_UDEV_CTRL,#0x01
                                    842 ;	src\usbhost.c:145: return (ERR_SUCCESS);
      0000D2 75 82 00         [24]  843 	mov	dpl, #0x00
      0000D5 22               [24]  844 	ret
      0000D6                        845 00108$:
                                    846 ;	src\usbhost.c:147: return (ERR_USB_DISCON);
      0000D6 75 82 16         [24]  847 	mov	dpl, #0x16
                                    848 ;	src\usbhost.c:148: }
      0000D9 22               [24]  849 	ret
                                    850 ;------------------------------------------------------------
                                    851 ;Allocation info for local variables in function 'SelectHubPort'
                                    852 ;------------------------------------------------------------
                                    853 ;	src\usbhost.c:157: void SelectHubPort(void)
                                    854 ;	-----------------------------------------
                                    855 ;	 function SelectHubPort
                                    856 ;	-----------------------------------------
      0000DA                        857 _SelectHubPort:
                                    858 ;	src\usbhost.c:161: SetHostUsbAddr(ThisUsbDev.DeviceAddress); // 设置USB主机当前操作的USB设备地址
      0000DA 90r00r01         [24]  859 	mov	dptr,#(_ThisUsbDev + 0x0001)
      0000DD E0               [24]  860 	movx	a,@dptr
      0000DE F5 82            [12]  861 	mov	dpl,a
      0000E0 12r00r3B         [24]  862 	lcall	_SetHostUsbAddr
                                    863 ;	src\usbhost.c:162: SetUsbSpeed(ThisUsbDev.DeviceSpeed);      // 设置USB设备的速度
      0000E3 90r00r02         [24]  864 	mov	dptr,#(_ThisUsbDev + 0x0002)
      0000E6 E0               [24]  865 	movx	a,@dptr
      0000E7 F5 82            [12]  866 	mov	dpl,a
                                    867 ;	src\usbhost.c:163: }
      0000E9 02r00r49         [24]  868 	ljmp	_SetUsbSpeed
                                    869 ;------------------------------------------------------------
                                    870 ;Allocation info for local variables in function 'WaitUSB_Interrupt'
                                    871 ;------------------------------------------------------------
                                    872 ;i                         Allocated to registers r6 r7 
                                    873 ;------------------------------------------------------------
                                    874 ;	src\usbhost.c:173: uint8_t WaitUSB_Interrupt(void)
                                    875 ;	-----------------------------------------
                                    876 ;	 function WaitUSB_Interrupt
                                    877 ;	-----------------------------------------
      0000EC                        878 _WaitUSB_Interrupt:
                                    879 ;	src\usbhost.c:176: for (i = WAIT_USB_TOUT_200US; i != 0 && UIF_TRANSFER == 0; i--)
      0000EC 7E 15            [12]  880 	mov	r6,#0x15
      0000EE 7F 02            [12]  881 	mov	r7,#0x02
      0000F0                        882 00104$:
      0000F0 EE               [12]  883 	mov	a,r6
      0000F1 4F               [12]  884 	orl	a,r7
      0000F2 60 0A            [24]  885 	jz	00101$
      0000F4 20 D9 07         [24]  886 	jb	_UIF_TRANSFER,00101$
      0000F7 1E               [12]  887 	dec	r6
      0000F8 BE FF 01         [24]  888 	cjne	r6,#0xff,00137$
      0000FB 1F               [12]  889 	dec	r7
      0000FC                        890 00137$:
      0000FC 80 F2            [24]  891 	sjmp	00104$
      0000FE                        892 00101$:
                                    893 ;	src\usbhost.c:180: return (UIF_TRANSFER ? ERR_SUCCESS : ERR_USB_UNKNOWN);
      0000FE 30 D9 04         [24]  894 	jnb	_UIF_TRANSFER,00108$
      000101 7F 00            [12]  895 	mov	r7,#0x00
      000103 80 02            [24]  896 	sjmp	00109$
      000105                        897 00108$:
      000105 7F FE            [12]  898 	mov	r7,#0xfe
      000107                        899 00109$:
      000107 8F 82            [24]  900 	mov	dpl,r7
                                    901 ;	src\usbhost.c:181: }
      000109 22               [24]  902 	ret
                                    903 ;------------------------------------------------------------
                                    904 ;Allocation info for local variables in function 'USBHostTransact'
                                    905 ;------------------------------------------------------------
                                    906 ;tog                       Allocated with name '_USBHostTransact_PARM_2'
                                    907 ;timeout                   Allocated with name '_USBHostTransact_PARM_3'
                                    908 ;endp_pid                  Allocated with name '_USBHostTransact_endp_pid_10000_117'
                                    909 ;TransRetry                Allocated with name '_USBHostTransact_TransRetry_10000_118'
                                    910 ;s                         Allocated to registers r7 
                                    911 ;r                         Allocated to registers r7 
                                    912 ;i                         Allocated to registers r0 r7 
                                    913 ;------------------------------------------------------------
                                    914 ;	src\usbhost.c:195: uint8_t USBHostTransact(uint8_t endp_pid, uint8_t tog, uint16_t timeout)
                                    915 ;	-----------------------------------------
                                    916 ;	 function USBHostTransact
                                    917 ;	-----------------------------------------
      00010A                        918 _USBHostTransact:
      00010A 85 82*03         [24]  919 	mov	_USBHostTransact_endp_pid_10000_117,dpl
                                    920 ;	src\usbhost.c:201: UH_RX_CTRL = UH_TX_CTRL = tog;
      00010D 85*00 D6         [24]  921 	mov	_UEP3_CTRL,_USBHostTransact_PARM_2
      000110 85*00 D4         [24]  922 	mov	_UEP2_CTRL,_USBHostTransact_PARM_2
                                    923 ;	src\usbhost.c:202: TransRetry = 0;
      000113 75*04 00         [24]  924 	mov	_USBHostTransact_TransRetry_10000_118,#0x00
                                    925 ;	src\usbhost.c:204: do
      000116 E5*03            [12]  926 	mov	a,_USBHostTransact_endp_pid_10000_117
      000118 C4               [12]  927 	swap	a
      000119 54 0F            [12]  928 	anl	a,#0x0f
      00011B FD               [12]  929 	mov	r5,a
      00011C BD 01 03         [24]  930 	cjne	r5,#0x01,00281$
      00011F ED               [12]  931 	mov	a,r5
      000120 80 01            [24]  932 	sjmp	00282$
      000122                        933 00281$:
      000122 E4               [12]  934 	clr	a
      000123                        935 00282$:
      000123 FC               [12]  936 	mov	r4,a
      000124 E4               [12]  937 	clr	a
      000125 BD 09 01         [24]  938 	cjne	r5,#0x09,00283$
      000128 04               [12]  939 	inc	a
      000129                        940 00283$:
      000129 FB               [12]  941 	mov	r3,a
      00012A A9*01            [24]  942 	mov	r1,_USBHostTransact_PARM_3
      00012C AA*02            [24]  943 	mov	r2,(_USBHostTransact_PARM_3 + 1)
      00012E                        944 00139$:
                                    945 ;	src\usbhost.c:206: UH_EP_PID = endp_pid; // Specify the token PID and destination endpoint number
      00012E 85*03 D5         [24]  946 	mov	_UEP2_T_LEN,_USBHostTransact_endp_pid_10000_117
                                    947 ;	src\usbhost.c:207: UIF_TRANSFER = 0;     // Allow transfer
                                    948 ;	assignBit
      000131 C2 D9            [12]  949 	clr	_UIF_TRANSFER
                                    950 ;	src\usbhost.c:209: for (i = WAIT_USB_TOUT_200US; i != 0 && UIF_TRANSFER == 0; i--)
      000133 78 15            [12]  951 	mov	r0,#0x15
      000135 7F 02            [12]  952 	mov	r7,#0x02
      000137                        953 00144$:
      000137 E8               [12]  954 	mov	a,r0
      000138 4F               [12]  955 	orl	a,r7
      000139 60 0A            [24]  956 	jz	00101$
      00013B 20 D9 07         [24]  957 	jb	_UIF_TRANSFER,00101$
      00013E 18               [12]  958 	dec	r0
      00013F B8 FF 01         [24]  959 	cjne	r0,#0xff,00287$
      000142 1F               [12]  960 	dec	r7
      000143                        961 00287$:
      000143 80 F2            [24]  962 	sjmp	00144$
      000145                        963 00101$:
                                    964 ;	src\usbhost.c:211: UH_EP_PID = 0x00; // Stop USB transfer
      000145 75 D5 00         [24]  965 	mov	_UEP2_T_LEN,#0x00
                                    966 ;	src\usbhost.c:213: if (UIF_TRANSFER == 0)
      000148 20 D9 04         [24]  967 	jb	_UIF_TRANSFER,00103$
                                    968 ;	src\usbhost.c:214: return (ERR_USB_UNKNOWN);
      00014B 75 82 FE         [24]  969 	mov	dpl, #0xfe
      00014E 22               [24]  970 	ret
      00014F                        971 00103$:
                                    972 ;	src\usbhost.c:215: if (UIF_DETECT)
                                    973 ;	src\usbhost.c:218: UIF_DETECT = 0;       // 清中断标志
                                    974 ;	assignBit
      00014F 10 D8 02         [24]  975 	jbc	_UIF_DETECT,00289$
      000152 80 4A            [24]  976 	sjmp	00111$
      000154                        977 00289$:
                                    978 ;	src\usbhost.c:219: s = AnalyzeRootHub(); // 分析ROOT-HUB状态
      000154 C0 05            [24]  979 	push	ar5
      000156 C0 04            [24]  980 	push	ar4
      000158 C0 03            [24]  981 	push	ar3
      00015A C0 02            [24]  982 	push	ar2
      00015C C0 01            [24]  983 	push	ar1
      00015E 12r00r0A         [24]  984 	lcall	_AnalyzeRootHub
      000161 AF 82            [24]  985 	mov	r7, dpl
      000163 D0 01            [24]  986 	pop	ar1
      000165 D0 02            [24]  987 	pop	ar2
      000167 D0 03            [24]  988 	pop	ar3
      000169 D0 04            [24]  989 	pop	ar4
      00016B D0 05            [24]  990 	pop	ar5
                                    991 ;	src\usbhost.c:220: if (s == ERR_USB_CONNECT) 
      00016D BF 15 02         [24]  992 	cjne	r7,#0x15,00105$
                                    993 ;	src\usbhost.c:221: FoundNewDev = 1;
                                    994 ;	assignBit
      000170 D2*00            [12]  995 	setb	_FoundNewDev
      000172                        996 00105$:
                                    997 ;	src\usbhost.c:222: if (ThisUsbDev.DeviceStatus == ROOT_DEV_DISCONNECT)
      000172 90r00r00         [24]  998 	mov	dptr,#_ThisUsbDev
      000175 E0               [24]  999 	movx	a,@dptr
      000176 FF               [12] 1000 	mov	r7,a
      000177 70 04            [24] 1001 	jnz	00107$
                                   1002 ;	src\usbhost.c:223: return (ERR_USB_DISCON); // USB设备断开事件
      000179 75 82 16         [24] 1003 	mov	dpl, #0x16
      00017C 22               [24] 1004 	ret
      00017D                       1005 00107$:
                                   1006 ;	src\usbhost.c:224: if (ThisUsbDev.DeviceStatus == ROOT_DEV_CONNECTED)
      00017D BF 01 04         [24] 1007 	cjne	r7,#0x01,00109$
                                   1008 ;	src\usbhost.c:225: return (ERR_USB_CONNECT); // USB设备连接事件
      000180 75 82 15         [24] 1009 	mov	dpl, #0x15
      000183 22               [24] 1010 	ret
      000184                       1011 00109$:
                                   1012 ;	src\usbhost.c:226: mDelayuS(200);                // 等待传输完成
      000184 90 00 C8         [24] 1013 	mov	dptr,#0x00c8
      000187 C0 05            [24] 1014 	push	ar5
      000189 C0 04            [24] 1015 	push	ar4
      00018B C0 03            [24] 1016 	push	ar3
      00018D C0 02            [24] 1017 	push	ar2
      00018F C0 01            [24] 1018 	push	ar1
      000191 12r00r00         [24] 1019 	lcall	_mDelayuS
      000194 D0 01            [24] 1020 	pop	ar1
      000196 D0 02            [24] 1021 	pop	ar2
      000198 D0 03            [24] 1022 	pop	ar3
      00019A D0 04            [24] 1023 	pop	ar4
      00019C D0 05            [24] 1024 	pop	ar5
      00019E                       1025 00111$:
                                   1026 ;	src\usbhost.c:228: if (UIF_TRANSFER)
      00019E 20 D9 03         [24] 1027 	jb	_UIF_TRANSFER,00295$
      0001A1 02r02r05         [24] 1028 	ljmp	00137$
      0001A4                       1029 00295$:
                                   1030 ;	src\usbhost.c:230: if (U_TOG_OK)
      0001A4 30 DE 04         [24] 1031 	jnb	_U_TOG_OK,00113$
                                   1032 ;	src\usbhost.c:231: return (ERR_SUCCESS);
      0001A7 75 82 00         [24] 1033 	mov	dpl, #0x00
      0001AA 22               [24] 1034 	ret
      0001AB                       1035 00113$:
                                   1036 ;	src\usbhost.c:232: r = USB_INT_ST & MASK_UIS_H_RES; // USB设备应答状态
      0001AB E5 D9            [12] 1037 	mov	a,_USB_INT_ST
      0001AD 54 0F            [12] 1038 	anl	a,#0x0f
      0001AF FF               [12] 1039 	mov	r7,a
                                   1040 ;	src\usbhost.c:233: if (r == USB_PID_STALL)
      0001B0 BF 0E 06         [24] 1041 	cjne	r7,#0x0e,00115$
                                   1042 ;	src\usbhost.c:234: return (r | ERR_USB_TRANSFER);
      0001B3 74 20            [12] 1043 	mov	a,#0x20
      0001B5 4F               [12] 1044 	orl	a,r7
      0001B6 F5 82            [12] 1045 	mov	dpl,a
      0001B8 22               [24] 1046 	ret
      0001B9                       1047 00115$:
                                   1048 ;	src\usbhost.c:235: if (r == USB_PID_NAK)
      0001B9 BF 0A 20         [24] 1049 	cjne	r7,#0x0a,00134$
                                   1050 ;	src\usbhost.c:237: if (timeout == 0)
      0001BC E9               [12] 1051 	mov	a,r1
      0001BD 4A               [12] 1052 	orl	a,r2
      0001BE 70 06            [24] 1053 	jnz	00117$
                                   1054 ;	src\usbhost.c:238: return (r | ERR_USB_TRANSFER);
      0001C0 74 20            [12] 1055 	mov	a,#0x20
      0001C2 4F               [12] 1056 	orl	a,r7
      0001C3 F5 82            [12] 1057 	mov	dpl,a
      0001C5 22               [24] 1058 	ret
      0001C6                       1059 00117$:
                                   1060 ;	src\usbhost.c:239: if (timeout < 0xFFFF)
      0001C6 89 00            [24] 1061 	mov	ar0,r1
      0001C8 8A 06            [24] 1062 	mov	ar6,r2
      0001CA C3               [12] 1063 	clr	c
      0001CB E8               [12] 1064 	mov	a,r0
      0001CC 94 FF            [12] 1065 	subb	a,#0xff
      0001CE EE               [12] 1066 	mov	a,r6
      0001CF 94 FF            [12] 1067 	subb	a,#0xff
      0001D1 50 05            [24] 1068 	jnc	00119$
                                   1069 ;	src\usbhost.c:240: timeout--;
      0001D3 19               [12] 1070 	dec	r1
      0001D4 B9 FF 01         [24] 1071 	cjne	r1,#0xff,00303$
      0001D7 1A               [12] 1072 	dec	r2
      0001D8                       1073 00303$:
      0001D8                       1074 00119$:
                                   1075 ;	src\usbhost.c:241: --TransRetry;
      0001D8 15*04            [12] 1076 	dec	_USBHostTransact_TransRetry_10000_118
      0001DA 80 2C            [24] 1077 	sjmp	00138$
      0001DC                       1078 00134$:
                                   1079 ;	src\usbhost.c:244: switch (endp_pid >> 4)
      0001DC EC               [12] 1080 	mov	a,r4
      0001DD 70 06            [24] 1081 	jnz	00121$
      0001DF EB               [12] 1082 	mov	a,r3
      0001E0 70 0C            [24] 1083 	jnz	00124$
      0001E2 BD 0D 1C         [24] 1084 	cjne	r5,#0x0d,00131$
                                   1085 ;	src\usbhost.c:247: case USB_PID_OUT:
      0001E5                       1086 00121$:
                                   1087 ;	src\usbhost.c:251: if (r)
      0001E5 EF               [12] 1088 	mov	a,r7
      0001E6 60 20            [24] 1089 	jz	00138$
                                   1090 ;	src\usbhost.c:252: return (r | ERR_USB_TRANSFER); // 不是超时/出错,意外应答
      0001E8 74 20            [12] 1091 	mov	a,#0x20
      0001EA 4F               [12] 1092 	orl	a,r7
      0001EB F5 82            [12] 1093 	mov	dpl,a
                                   1094 ;	src\usbhost.c:254: case USB_PID_IN:
      0001ED 22               [24] 1095 	ret
      0001EE                       1096 00124$:
                                   1097 ;	src\usbhost.c:258: if (r == USB_PID_DATA0 || r == USB_PID_DATA1)
      0001EE BF 03 02         [24] 1098 	cjne	r7,#0x03,00309$
      0001F1 80 15            [24] 1099 	sjmp	00138$
      0001F3                       1100 00309$:
      0001F3 BF 0B 02         [24] 1101 	cjne	r7,#0x0b,00310$
      0001F6 80 10            [24] 1102 	sjmp	00138$
      0001F8                       1103 00310$:
                                   1104 ;	src\usbhost.c:261: else if (r)
      0001F8 EF               [12] 1105 	mov	a,r7
      0001F9 60 0D            [24] 1106 	jz	00138$
                                   1107 ;	src\usbhost.c:262: return (r | ERR_USB_TRANSFER); // 不是超时/出错,意外应答
      0001FB 74 20            [12] 1108 	mov	a,#0x20
      0001FD 4F               [12] 1109 	orl	a,r7
      0001FE F5 82            [12] 1110 	mov	dpl,a
                                   1111 ;	src\usbhost.c:264: default:
      000200 22               [24] 1112 	ret
      000201                       1113 00131$:
                                   1114 ;	src\usbhost.c:265: return (ERR_USB_UNKNOWN); // 不可能的情况
      000201 75 82 FE         [24] 1115 	mov	dpl, #0xfe
                                   1116 ;	src\usbhost.c:267: }
      000204 22               [24] 1117 	ret
      000205                       1118 00137$:
                                   1119 ;	src\usbhost.c:271: USB_INT_FG = 0xFF; /* 清中断标志 */
      000205 75 D8 FF         [24] 1120 	mov	_USB_INT_FG,#0xff
      000208                       1121 00138$:
                                   1122 ;	src\usbhost.c:273: mDelayuS(15);
      000208 90 00 0F         [24] 1123 	mov	dptr,#0x000f
      00020B C0 05            [24] 1124 	push	ar5
      00020D C0 04            [24] 1125 	push	ar4
      00020F C0 03            [24] 1126 	push	ar3
      000211 C0 02            [24] 1127 	push	ar2
      000213 C0 01            [24] 1128 	push	ar1
      000215 12r00r00         [24] 1129 	lcall	_mDelayuS
      000218 D0 01            [24] 1130 	pop	ar1
      00021A D0 02            [24] 1131 	pop	ar2
      00021C D0 03            [24] 1132 	pop	ar3
      00021E D0 04            [24] 1133 	pop	ar4
      000220 D0 05            [24] 1134 	pop	ar5
                                   1135 ;	src\usbhost.c:274: } while (++TransRetry < 3);
      000222 05*04            [12] 1136 	inc	_USBHostTransact_TransRetry_10000_118
      000224 74 FD            [12] 1137 	mov	a,#0x100 - 0x03
      000226 25*04            [12] 1138 	add	a,_USBHostTransact_TransRetry_10000_118
      000228 40 03            [24] 1139 	jc	00312$
      00022A 02r01r2E         [24] 1140 	ljmp	00139$
      00022D                       1141 00312$:
                                   1142 ;	src\usbhost.c:275: return (ERR_USB_TRANSFER); // 应答超时
      00022D 75 82 20         [24] 1143 	mov	dpl, #0x20
                                   1144 ;	src\usbhost.c:276: }
      000230 22               [24] 1145 	ret
                                   1146 ;------------------------------------------------------------
                                   1147 ;Allocation info for local variables in function 'HostCtrlTransfer'
                                   1148 ;------------------------------------------------------------
                                   1149 ;RetLen                    Allocated with name '_HostCtrlTransfer_PARM_2'
                                   1150 ;DataBuf                   Allocated to registers 
                                   1151 ;RemLen                    Allocated to registers r1 r2 
                                   1152 ;s                         Allocated to registers r7 
                                   1153 ;RxLen                     Allocated with name '_HostCtrlTransfer_RxLen_10000_128'
                                   1154 ;RxCnt                     Allocated to registers r5 
                                   1155 ;TxCnt                     Allocated to registers r5 
                                   1156 ;pBuf                      Allocated with name '_HostCtrlTransfer_pBuf_10000_128'
                                   1157 ;pLen                      Allocated with name '_HostCtrlTransfer_pLen_10000_128'
                                   1158 ;------------------------------------------------------------
                                   1159 ;	src\usbhost.c:287: uint8_t HostCtrlTransfer(__xdata uint8_t *DataBuf, uint8_t *RetLen)
                                   1160 ;	-----------------------------------------
                                   1161 ;	 function HostCtrlTransfer
                                   1162 ;	-----------------------------------------
      000231                       1163 _HostCtrlTransfer:
      000231 85 82*09         [24] 1164 	mov	_HostCtrlTransfer_pBuf_10000_128,dpl
      000234 85 83*0A         [24] 1165 	mov	(_HostCtrlTransfer_pBuf_10000_128 + 1),dph
                                   1166 ;	src\usbhost.c:294: pLen = RetLen;
      000237 85*05*0B         [24] 1167 	mov	_HostCtrlTransfer_pLen_10000_128,_HostCtrlTransfer_PARM_2
      00023A 85*06*0C         [24] 1168 	mov	(_HostCtrlTransfer_pLen_10000_128 + 1),(_HostCtrlTransfer_PARM_2 + 1)
      00023D 85*07*0D         [24] 1169 	mov	(_HostCtrlTransfer_pLen_10000_128 + 2),(_HostCtrlTransfer_PARM_2 + 2)
                                   1170 ;	src\usbhost.c:295: mDelayuS(200);
      000240 90 00 C8         [24] 1171 	mov	dptr,#0x00c8
      000243 12r00r00         [24] 1172 	lcall	_mDelayuS
                                   1173 ;	src\usbhost.c:296: if (pLen)
      000246 E5*0B            [12] 1174 	mov	a,_HostCtrlTransfer_pLen_10000_128
      000248 45*0C            [12] 1175 	orl	a,(_HostCtrlTransfer_pLen_10000_128 + 1)
      00024A 60 0D            [24] 1176 	jz	00102$
                                   1177 ;	src\usbhost.c:298: *pLen = 0; // 实际成功收发的总长度
      00024C 85*0B 82         [24] 1178 	mov	dpl,_HostCtrlTransfer_pLen_10000_128
      00024F 85*0C 83         [24] 1179 	mov	dph,(_HostCtrlTransfer_pLen_10000_128 + 1)
      000252 85*0D F0         [24] 1180 	mov	b,(_HostCtrlTransfer_pLen_10000_128 + 2)
      000255 E4               [12] 1181 	clr	a
      000256 12r00r00         [24] 1182 	lcall	__gptrput
      000259                       1183 00102$:
                                   1184 ;	src\usbhost.c:300: UH_TX_LEN = sizeof(USB_SETUP_REQ);
      000259 75 D7 08         [24] 1185 	mov	_UEP3_T_LEN,#0x08
                                   1186 ;	src\usbhost.c:301: s = USBHostTransact((uint8_t)(USB_PID_SETUP << 4 | 0x00), 0x00, 10000); // SETUP阶段,200mS超时
      00025C 75*00 00         [24] 1187 	mov	_USBHostTransact_PARM_2,#0x00
      00025F 75*01 10         [24] 1188 	mov	_USBHostTransact_PARM_3,#0x10
      000262 75*02 27         [24] 1189 	mov	(_USBHostTransact_PARM_3 + 1),#0x27
      000265 75 82 D0         [24] 1190 	mov	dpl, #0xd0
      000268 12r01r0A         [24] 1191 	lcall	_USBHostTransact
                                   1192 ;	src\usbhost.c:302: if (s != ERR_SUCCESS)
      00026B E5 82            [12] 1193 	mov	a,dpl
      00026D FA               [12] 1194 	mov	r2,a
      00026E 60 03            [24] 1195 	jz	00104$
                                   1196 ;	src\usbhost.c:304: return (s);
      000270 8A 82            [24] 1197 	mov	dpl, r2
      000272 22               [24] 1198 	ret
      000273                       1199 00104$:
                                   1200 ;	src\usbhost.c:306: UH_RX_CTRL = UH_TX_CTRL = bUH_R_TOG | bUH_R_AUTO_TOG | bUH_T_TOG | bUH_T_AUTO_TOG; // 默认DATA1
      000273 75 D6 D0         [24] 1201 	mov	_UEP3_CTRL,#0xd0
      000276 75 D4 D0         [24] 1202 	mov	_UEP2_CTRL,#0xd0
                                   1203 ;	src\usbhost.c:307: UH_TX_LEN = 0x01;                                                                  // 默认无数据故状态阶段为IN
      000279 75 D7 01         [24] 1204 	mov	_UEP3_T_LEN,#0x01
                                   1205 ;	src\usbhost.c:308: RemLen = (pSetupReq->wLengthH << 8) | (pSetupReq->wLengthL);
      00027C 90r00r07         [24] 1206 	mov	dptr,#(_TxBuffer + 0x0007)
      00027F E0               [24] 1207 	movx	a,@dptr
      000280 FA               [12] 1208 	mov	r2,a
      000281 79 00            [12] 1209 	mov	r1,#0x00
      000283 90r00r06         [24] 1210 	mov	dptr,#(_TxBuffer + 0x0006)
      000286 E0               [24] 1211 	movx	a,@dptr
      000287 7F 00            [12] 1212 	mov	r7,#0x00
      000289 42 01            [12] 1213 	orl	ar1,a
      00028B EF               [12] 1214 	mov	a,r7
      00028C 42 02            [12] 1215 	orl	ar2,a
                                   1216 ;	src\usbhost.c:309: if (RemLen && pBuf) // 需要收发数据
      00028E E9               [12] 1217 	mov	a,r1
      00028F 4A               [12] 1218 	orl	a,r2
      000290 70 03            [24] 1219 	jnz	00324$
      000292 02r04r2F         [24] 1220 	ljmp	00130$
      000295                       1221 00324$:
      000295 E5*09            [12] 1222 	mov	a,_HostCtrlTransfer_pBuf_10000_128
      000297 45*0A            [12] 1223 	orl	a,(_HostCtrlTransfer_pBuf_10000_128 + 1)
      000299 70 03            [24] 1224 	jnz	00325$
      00029B 02r04r2F         [24] 1225 	ljmp	00130$
      00029E                       1226 00325$:
                                   1227 ;	src\usbhost.c:311: if (pSetupReq->bRequestType & USB_REQ_TYP_IN) // 收
      00029E 90r00r00         [24] 1228 	mov	dptr,#_TxBuffer
      0002A1 E0               [24] 1229 	movx	a,@dptr
      0002A2 20 E7 03         [24] 1230 	jb	acc.7,00326$
      0002A5 02r03r68         [24] 1231 	ljmp	00123$
      0002A8                       1232 00326$:
                                   1233 ;	src\usbhost.c:313: while (RemLen)
      0002A8                       1234 00113$:
      0002A8 E9               [12] 1235 	mov	a,r1
      0002A9 4A               [12] 1236 	orl	a,r2
      0002AA 70 03            [24] 1237 	jnz	00327$
      0002AC 02r03r62         [24] 1238 	ljmp	00115$
      0002AF                       1239 00327$:
                                   1240 ;	src\usbhost.c:315: mDelayuS(200);
      0002AF 90 00 C8         [24] 1241 	mov	dptr,#0x00c8
      0002B2 C0 02            [24] 1242 	push	ar2
      0002B4 C0 01            [24] 1243 	push	ar1
      0002B6 12r00r00         [24] 1244 	lcall	_mDelayuS
                                   1245 ;	src\usbhost.c:316: s = USBHostTransact((uint8_t)(USB_PID_IN << 4 | 0x00), UH_RX_CTRL, 200000 / 20); // IN数据
      0002B9 85 D4*00         [24] 1246 	mov	_USBHostTransact_PARM_2,_UEP2_CTRL
      0002BC 75*01 10         [24] 1247 	mov	_USBHostTransact_PARM_3,#0x10
      0002BF 75*02 27         [24] 1248 	mov	(_USBHostTransact_PARM_3 + 1),#0x27
      0002C2 75 82 90         [24] 1249 	mov	dpl, #0x90
      0002C5 12r01r0A         [24] 1250 	lcall	_USBHostTransact
      0002C8 AF 82            [24] 1251 	mov	r7, dpl
      0002CA D0 01            [24] 1252 	pop	ar1
      0002CC D0 02            [24] 1253 	pop	ar2
                                   1254 ;	src\usbhost.c:317: if (s != ERR_SUCCESS)
      0002CE EF               [12] 1255 	mov	a,r7
      0002CF 60 03            [24] 1256 	jz	00106$
                                   1257 ;	src\usbhost.c:319: return (s);
      0002D1 8F 82            [24] 1258 	mov	dpl, r7
      0002D3 22               [24] 1259 	ret
      0002D4                       1260 00106$:
                                   1261 ;	src\usbhost.c:321: RxLen = USB_RX_LEN < RemLen ? USB_RX_LEN : RemLen;
      0002D4 AE DB            [24] 1262 	mov	r6,_USB_RX_LEN
      0002D6 7F 00            [12] 1263 	mov	r7,#0x00
      0002D8 C3               [12] 1264 	clr	c
      0002D9 EE               [12] 1265 	mov	a,r6
      0002DA 99               [12] 1266 	subb	a,r1
      0002DB EF               [12] 1267 	mov	a,r7
      0002DC 9A               [12] 1268 	subb	a,r2
      0002DD 50 04            [24] 1269 	jnc	00146$
      0002DF AE DB            [24] 1270 	mov	r6,_USB_RX_LEN
      0002E1 80 04            [24] 1271 	sjmp	00147$
      0002E3                       1272 00146$:
      0002E3 89 06            [24] 1273 	mov	ar6,r1
      0002E5 8A 07            [24] 1274 	mov	ar7,r2
      0002E7                       1275 00147$:
      0002E7 8E*08            [24] 1276 	mov	_HostCtrlTransfer_RxLen_10000_128,r6
                                   1277 ;	src\usbhost.c:322: RemLen -= RxLen;
      0002E9 AF*08            [24] 1278 	mov	r7,_HostCtrlTransfer_RxLen_10000_128
      0002EB 89 00            [24] 1279 	mov	ar0,r1
      0002ED 8A 06            [24] 1280 	mov	ar6,r2
      0002EF 8F 05            [24] 1281 	mov	ar5,r7
      0002F1 7F 00            [12] 1282 	mov	r7,#0x00
      0002F3 E8               [12] 1283 	mov	a,r0
      0002F4 C3               [12] 1284 	clr	c
      0002F5 9D               [12] 1285 	subb	a,r5
      0002F6 F8               [12] 1286 	mov	r0,a
      0002F7 EE               [12] 1287 	mov	a,r6
      0002F8 9F               [12] 1288 	subb	a,r7
      0002F9 FE               [12] 1289 	mov	r6,a
      0002FA 88 01            [24] 1290 	mov	ar1,r0
      0002FC 8E 02            [24] 1291 	mov	ar2,r6
                                   1292 ;	src\usbhost.c:323: if (pLen)
      0002FE E5*0B            [12] 1293 	mov	a,_HostCtrlTransfer_pLen_10000_128
      000300 45*0C            [12] 1294 	orl	a,(_HostCtrlTransfer_pLen_10000_128 + 1)
      000302 60 1A            [24] 1295 	jz	00161$
                                   1296 ;	src\usbhost.c:325: *pLen += RxLen; // 实际成功收发的总长度
      000304 85*0B 82         [24] 1297 	mov	dpl,_HostCtrlTransfer_pLen_10000_128
      000307 85*0C 83         [24] 1298 	mov	dph,(_HostCtrlTransfer_pLen_10000_128 + 1)
      00030A 85*0D F0         [24] 1299 	mov	b,(_HostCtrlTransfer_pLen_10000_128 + 2)
      00030D 12r00r00         [24] 1300 	lcall	__gptrget
      000310 25*08            [12] 1301 	add	a,_HostCtrlTransfer_RxLen_10000_128
      000312 85*0B 82         [24] 1302 	mov	dpl,_HostCtrlTransfer_pLen_10000_128
      000315 85*0C 83         [24] 1303 	mov	dph,(_HostCtrlTransfer_pLen_10000_128 + 1)
      000318 85*0D F0         [24] 1304 	mov	b,(_HostCtrlTransfer_pLen_10000_128 + 2)
      00031B 12r00r00         [24] 1305 	lcall	__gptrput
                                   1306 ;	src\usbhost.c:329: for (RxCnt = 0; RxCnt != RxLen; RxCnt++)
      00031E                       1307 00161$:
      00031E AE*09            [24] 1308 	mov	r6,_HostCtrlTransfer_pBuf_10000_128
      000320 AF*0A            [24] 1309 	mov	r7,(_HostCtrlTransfer_pBuf_10000_128 + 1)
      000322 7D 00            [12] 1310 	mov	r5,#0x00
      000324                       1311 00139$:
      000324 ED               [12] 1312 	mov	a,r5
      000325 B5*08 02         [24] 1313 	cjne	a,_HostCtrlTransfer_RxLen_10000_128,00331$
      000328 80 13            [24] 1314 	sjmp	00176$
      00032A                       1315 00331$:
                                   1316 ;	src\usbhost.c:331: *pBuf = RxBuffer[RxCnt];
      00032A 8D 82            [24] 1317 	mov	dpl,r5
      00032C 75 83s00         [24] 1318 	mov	dph,#(_RxBuffer >> 8)
      00032F E0               [24] 1319 	movx	a,@dptr
      000330 8E 82            [24] 1320 	mov	dpl,r6
      000332 8F 83            [24] 1321 	mov	dph,r7
      000334 F0               [24] 1322 	movx	@dptr,a
      000335 A3               [24] 1323 	inc	dptr
      000336 AE 82            [24] 1324 	mov	r6,dpl
      000338 AF 83            [24] 1325 	mov	r7,dph
                                   1326 ;	src\usbhost.c:332: pBuf++;
                                   1327 ;	src\usbhost.c:329: for (RxCnt = 0; RxCnt != RxLen; RxCnt++)
      00033A 0D               [12] 1328 	inc	r5
      00033B 80 E7            [24] 1329 	sjmp	00139$
      00033D                       1330 00176$:
      00033D 8E*09            [24] 1331 	mov	_HostCtrlTransfer_pBuf_10000_128,r6
      00033F 8F*0A            [24] 1332 	mov	(_HostCtrlTransfer_pBuf_10000_128 + 1),r7
                                   1333 ;	src\usbhost.c:334: if (USB_RX_LEN == 0 || (USB_RX_LEN & (UsbDevEndp0Size - 1)))
      000341 E5 DB            [12] 1334 	mov	a,_USB_RX_LEN
      000343 60 1D            [24] 1335 	jz	00115$
      000345 90r00r00         [24] 1336 	mov	dptr,#_UsbDevEndp0Size
      000348 E0               [24] 1337 	movx	a,@dptr
      000349 FF               [12] 1338 	mov	r7,a
      00034A 7E 00            [12] 1339 	mov	r6,#0x00
      00034C 1F               [12] 1340 	dec	r7
      00034D BF FF 01         [24] 1341 	cjne	r7,#0xff,00333$
      000350 1E               [12] 1342 	dec	r6
      000351                       1343 00333$:
      000351 AC DB            [24] 1344 	mov	r4,_USB_RX_LEN
      000353 7D 00            [12] 1345 	mov	r5,#0x00
      000355 EC               [12] 1346 	mov	a,r4
      000356 52 07            [12] 1347 	anl	ar7,a
      000358 ED               [12] 1348 	mov	a,r5
      000359 52 06            [12] 1349 	anl	ar6,a
      00035B EF               [12] 1350 	mov	a,r7
      00035C 4E               [12] 1351 	orl	a,r6
      00035D 70 03            [24] 1352 	jnz	00334$
      00035F 02r02rA8         [24] 1353 	ljmp	00113$
      000362                       1354 00334$:
                                   1355 ;	src\usbhost.c:336: break; // 短包
      000362                       1356 00115$:
                                   1357 ;	src\usbhost.c:339: UH_TX_LEN = 0x00; // 状态阶段为OUT
      000362 75 D7 00         [24] 1358 	mov	_UEP3_T_LEN,#0x00
      000365 02r04r2F         [24] 1359 	ljmp	00130$
                                   1360 ;	src\usbhost.c:343: while (RemLen)
      000368                       1361 00123$:
      000368 E9               [12] 1362 	mov	a,r1
      000369 4A               [12] 1363 	orl	a,r2
      00036A 70 03            [24] 1364 	jnz	00335$
      00036C 02r04r2F         [24] 1365 	ljmp	00130$
      00036F                       1366 00335$:
                                   1367 ;	src\usbhost.c:345: mDelayuS(200);
      00036F 90 00 C8         [24] 1368 	mov	dptr,#0x00c8
      000372 C0 02            [24] 1369 	push	ar2
      000374 C0 01            [24] 1370 	push	ar1
      000376 12r00r00         [24] 1371 	lcall	_mDelayuS
      000379 D0 01            [24] 1372 	pop	ar1
      00037B D0 02            [24] 1373 	pop	ar2
                                   1374 ;	src\usbhost.c:346: UH_TX_LEN = RemLen >= UsbDevEndp0Size ? UsbDevEndp0Size : RemLen;
      00037D 90r00r00         [24] 1375 	mov	dptr,#_UsbDevEndp0Size
      000380 E0               [24] 1376 	movx	a,@dptr
      000381 FE               [12] 1377 	mov	r6,a
      000382 7F 00            [12] 1378 	mov	r7,#0x00
      000384 C3               [12] 1379 	clr	c
      000385 E9               [12] 1380 	mov	a,r1
      000386 9E               [12] 1381 	subb	a,r6
      000387 EA               [12] 1382 	mov	a,r2
      000388 9F               [12] 1383 	subb	a,r7
      000389 92*00            [24] 1384 	mov	_HostCtrlTransfer_sloc0_1_0,c
      00038B 50 04            [24] 1385 	jnc	00149$
      00038D 89 06            [24] 1386 	mov	ar6,r1
      00038F 8A 07            [24] 1387 	mov	ar7,r2
      000391                       1388 00149$:
      000391 8E D7            [24] 1389 	mov	_UEP3_T_LEN,r6
                                   1390 ;	src\usbhost.c:349: if (pBuf[1] == 0x09) // HID类命令处理
      000393 85*09 82         [24] 1391 	mov	dpl,_HostCtrlTransfer_pBuf_10000_128
      000396 85*0A 83         [24] 1392 	mov	dph,(_HostCtrlTransfer_pBuf_10000_128 + 1)
      000399 A3               [24] 1393 	inc	dptr
      00039A E0               [24] 1394 	movx	a,@dptr
      00039B FF               [12] 1395 	mov	r7,a
      00039C BF 09 0C         [24] 1396 	cjne	r7,#0x09,00168$
                                   1397 ;	src\usbhost.c:351: Set_Port = Set_Port ^ 1;
      00039F 63*00 01         [24] 1398 	xrl	_Set_Port,#0x01
                                   1399 ;	src\usbhost.c:352: *pBuf = Set_Port;
      0003A2 85*09 82         [24] 1400 	mov	dpl,_HostCtrlTransfer_pBuf_10000_128
      0003A5 85*0A 83         [24] 1401 	mov	dph,(_HostCtrlTransfer_pBuf_10000_128 + 1)
      0003A8 E5*00            [12] 1402 	mov	a,_Set_Port
      0003AA F0               [24] 1403 	movx	@dptr,a
                                   1404 ;	src\usbhost.c:360: for (TxCnt = 0; TxCnt != UH_TX_LEN; TxCnt++)
      0003AB                       1405 00168$:
      0003AB AE*09            [24] 1406 	mov	r6,_HostCtrlTransfer_pBuf_10000_128
      0003AD AF*0A            [24] 1407 	mov	r7,(_HostCtrlTransfer_pBuf_10000_128 + 1)
      0003AF 7D 00            [12] 1408 	mov	r5,#0x00
      0003B1                       1409 00142$:
      0003B1 ED               [12] 1410 	mov	a,r5
      0003B2 B5 D7 02         [24] 1411 	cjne	a,_UEP3_T_LEN,00339$
      0003B5 80 1C            [24] 1412 	sjmp	00177$
      0003B7                       1413 00339$:
                                   1414 ;	src\usbhost.c:362: TxBuffer[TxCnt] = *pBuf;
      0003B7 ED               [12] 1415 	mov	a,r5
      0003B8 24r00            [12] 1416 	add	a, #_TxBuffer
      0003BA FB               [12] 1417 	mov	r3,a
      0003BB E4               [12] 1418 	clr	a
      0003BC 34s00            [12] 1419 	addc	a, #(_TxBuffer >> 8)
      0003BE FC               [12] 1420 	mov	r4,a
      0003BF 8E 82            [24] 1421 	mov	dpl,r6
      0003C1 8F 83            [24] 1422 	mov	dph,r7
      0003C3 E0               [24] 1423 	movx	a,@dptr
      0003C4 F8               [12] 1424 	mov	r0,a
      0003C5 A3               [24] 1425 	inc	dptr
      0003C6 AE 82            [24] 1426 	mov	r6,dpl
      0003C8 AF 83            [24] 1427 	mov	r7,dph
      0003CA 8B 82            [24] 1428 	mov	dpl,r3
      0003CC 8C 83            [24] 1429 	mov	dph,r4
      0003CE E8               [12] 1430 	mov	a,r0
      0003CF F0               [24] 1431 	movx	@dptr,a
                                   1432 ;	src\usbhost.c:363: pBuf++;
                                   1433 ;	src\usbhost.c:360: for (TxCnt = 0; TxCnt != UH_TX_LEN; TxCnt++)
      0003D0 0D               [12] 1434 	inc	r5
      0003D1 80 DE            [24] 1435 	sjmp	00142$
      0003D3                       1436 00177$:
      0003D3 8E*09            [24] 1437 	mov	_HostCtrlTransfer_pBuf_10000_128,r6
      0003D5 8F*0A            [24] 1438 	mov	(_HostCtrlTransfer_pBuf_10000_128 + 1),r7
                                   1439 ;	src\usbhost.c:365: s = USBHostTransact(USB_PID_OUT << 4 | 0x00, UH_TX_CTRL, 200000 / 20); // OUT数据
      0003D7 85 D6*00         [24] 1440 	mov	_USBHostTransact_PARM_2,_UEP3_CTRL
      0003DA 75*01 10         [24] 1441 	mov	_USBHostTransact_PARM_3,#0x10
      0003DD 75*02 27         [24] 1442 	mov	(_USBHostTransact_PARM_3 + 1),#0x27
      0003E0 75 82 10         [24] 1443 	mov	dpl, #0x10
      0003E3 C0 02            [24] 1444 	push	ar2
      0003E5 C0 01            [24] 1445 	push	ar1
      0003E7 12r01r0A         [24] 1446 	lcall	_USBHostTransact
      0003EA AF 82            [24] 1447 	mov	r7, dpl
      0003EC D0 01            [24] 1448 	pop	ar1
      0003EE D0 02            [24] 1449 	pop	ar2
                                   1450 ;	src\usbhost.c:366: if (s != ERR_SUCCESS)
      0003F0 EF               [12] 1451 	mov	a,r7
      0003F1 60 03            [24] 1452 	jz	00120$
                                   1453 ;	src\usbhost.c:368: return (s);
      0003F3 8F 82            [24] 1454 	mov	dpl, r7
      0003F5 22               [24] 1455 	ret
      0003F6                       1456 00120$:
                                   1457 ;	src\usbhost.c:370: RemLen -= UH_TX_LEN;
      0003F6 AF D7            [24] 1458 	mov	r7,_UEP3_T_LEN
      0003F8 89 05            [24] 1459 	mov	ar5,r1
      0003FA 8A 06            [24] 1460 	mov	ar6,r2
      0003FC 7C 00            [12] 1461 	mov	r4,#0x00
      0003FE ED               [12] 1462 	mov	a,r5
      0003FF C3               [12] 1463 	clr	c
      000400 9F               [12] 1464 	subb	a,r7
      000401 FD               [12] 1465 	mov	r5,a
      000402 EE               [12] 1466 	mov	a,r6
      000403 9C               [12] 1467 	subb	a,r4
      000404 FE               [12] 1468 	mov	r6,a
      000405 8D 01            [24] 1469 	mov	ar1,r5
      000407 8E 02            [24] 1470 	mov	ar2,r6
                                   1471 ;	src\usbhost.c:371: if (pLen)
      000409 E5*0B            [12] 1472 	mov	a,_HostCtrlTransfer_pLen_10000_128
      00040B 45*0C            [12] 1473 	orl	a,(_HostCtrlTransfer_pLen_10000_128 + 1)
      00040D 70 03            [24] 1474 	jnz	00341$
      00040F 02r03r68         [24] 1475 	ljmp	00123$
      000412                       1476 00341$:
                                   1477 ;	src\usbhost.c:373: *pLen += UH_TX_LEN; // 实际成功收发的总长度
      000412 85*0B 82         [24] 1478 	mov	dpl,_HostCtrlTransfer_pLen_10000_128
      000415 85*0C 83         [24] 1479 	mov	dph,(_HostCtrlTransfer_pLen_10000_128 + 1)
      000418 85*0D F0         [24] 1480 	mov	b,(_HostCtrlTransfer_pLen_10000_128 + 2)
      00041B 12r00r00         [24] 1481 	lcall	__gptrget
      00041E 25 D7            [12] 1482 	add	a,_UEP3_T_LEN
      000420 85*0B 82         [24] 1483 	mov	dpl,_HostCtrlTransfer_pLen_10000_128
      000423 85*0C 83         [24] 1484 	mov	dph,(_HostCtrlTransfer_pLen_10000_128 + 1)
      000426 85*0D F0         [24] 1485 	mov	b,(_HostCtrlTransfer_pLen_10000_128 + 2)
      000429 12r00r00         [24] 1486 	lcall	__gptrput
      00042C 02r03r68         [24] 1487 	ljmp	00123$
      00042F                       1488 00130$:
                                   1489 ;	src\usbhost.c:379: mDelayuS(200);
      00042F 90 00 C8         [24] 1490 	mov	dptr,#0x00c8
      000432 12r00r00         [24] 1491 	lcall	_mDelayuS
                                   1492 ;	src\usbhost.c:380: s = USBHostTransact((UH_TX_LEN ? USB_PID_IN << 4 | 0x00 : USB_PID_OUT << 4 | 0x00), bUH_R_TOG | bUH_T_TOG, 200000 / 20); // STATUS阶段
      000435 E5 D7            [12] 1493 	mov	a,_UEP3_T_LEN
      000437 60 04            [24] 1494 	jz	00150$
      000439 7F 90            [12] 1495 	mov	r7,#0x90
      00043B 80 02            [24] 1496 	sjmp	00151$
      00043D                       1497 00150$:
      00043D 7F 10            [12] 1498 	mov	r7,#0x10
      00043F                       1499 00151$:
      00043F 75*00 C0         [24] 1500 	mov	_USBHostTransact_PARM_2,#0xc0
      000442 75*01 10         [24] 1501 	mov	_USBHostTransact_PARM_3,#0x10
      000445 75*02 27         [24] 1502 	mov	(_USBHostTransact_PARM_3 + 1),#0x27
      000448 8F 82            [24] 1503 	mov	dpl, r7
      00044A 12r01r0A         [24] 1504 	lcall	_USBHostTransact
                                   1505 ;	src\usbhost.c:381: if (s != ERR_SUCCESS)
      00044D E5 82            [12] 1506 	mov	a,dpl
      00044F FF               [12] 1507 	mov	r7,a
      000450 60 03            [24] 1508 	jz	00133$
                                   1509 ;	src\usbhost.c:383: return (s);
      000452 8F 82            [24] 1510 	mov	dpl, r7
      000454 22               [24] 1511 	ret
      000455                       1512 00133$:
                                   1513 ;	src\usbhost.c:385: if (UH_TX_LEN == 0)
      000455 E5 D7            [12] 1514 	mov	a,_UEP3_T_LEN
                                   1515 ;	src\usbhost.c:387: return (ERR_SUCCESS); // 状态OUT
      000457 70 03            [24] 1516 	jnz	00135$
      000459 F5 82            [12] 1517 	mov	dpl,a
      00045B 22               [24] 1518 	ret
      00045C                       1519 00135$:
                                   1520 ;	src\usbhost.c:389: if (USB_RX_LEN == 0)
      00045C E5 DB            [12] 1521 	mov	a,_USB_RX_LEN
                                   1522 ;	src\usbhost.c:391: return (ERR_SUCCESS); // 状态IN,检查IN状态返回数据长度
      00045E 70 03            [24] 1523 	jnz	00137$
      000460 F5 82            [12] 1524 	mov	dpl,a
      000462 22               [24] 1525 	ret
      000463                       1526 00137$:
                                   1527 ;	src\usbhost.c:393: return (ERR_USB_BUF_OVER); // IN状态阶段错误
      000463 75 82 17         [24] 1528 	mov	dpl, #0x17
                                   1529 ;	src\usbhost.c:394: }
      000466 22               [24] 1530 	ret
                                   1531 ;------------------------------------------------------------
                                   1532 ;Allocation info for local variables in function 'CopySetupReqPkg'
                                   1533 ;------------------------------------------------------------
                                   1534 ;pReqPkt                   Allocated to registers 
                                   1535 ;i                         Allocated to registers r5 
                                   1536 ;------------------------------------------------------------
                                   1537 ;	src\usbhost.c:402: void CopySetupReqPkg(__code uint8_t *pReqPkt) // 复制控制传输的请求包
                                   1538 ;	-----------------------------------------
                                   1539 ;	 function CopySetupReqPkg
                                   1540 ;	-----------------------------------------
      000467                       1541 _CopySetupReqPkg:
      000467 AE 82            [24] 1542 	mov	r6, dpl
      000469 AF 83            [24] 1543 	mov	r7, dph
                                   1544 ;	src\usbhost.c:405: for (i = 0; i != sizeof(USB_SETUP_REQ); i++)
      00046B 7D 00            [12] 1545 	mov	r5,#0x00
      00046D                       1546 00102$:
                                   1547 ;	src\usbhost.c:407: ((__xdata uint8_t *)pSetupReq)[i] = *pReqPkt;
      00046D ED               [12] 1548 	mov	a,r5
      00046E 24r00            [12] 1549 	add	a, #_TxBuffer
      000470 FB               [12] 1550 	mov	r3,a
      000471 E4               [12] 1551 	clr	a
      000472 34s00            [12] 1552 	addc	a, #(_TxBuffer >> 8)
      000474 FC               [12] 1553 	mov	r4,a
      000475 8E 82            [24] 1554 	mov	dpl,r6
      000477 8F 83            [24] 1555 	mov	dph,r7
      000479 E4               [12] 1556 	clr	a
      00047A 93               [24] 1557 	movc	a,@a+dptr
      00047B FA               [12] 1558 	mov	r2,a
      00047C A3               [24] 1559 	inc	dptr
      00047D AE 82            [24] 1560 	mov	r6,dpl
      00047F AF 83            [24] 1561 	mov	r7,dph
      000481 8B 82            [24] 1562 	mov	dpl,r3
      000483 8C 83            [24] 1563 	mov	dph,r4
      000485 EA               [12] 1564 	mov	a,r2
      000486 F0               [24] 1565 	movx	@dptr,a
                                   1566 ;	src\usbhost.c:408: pReqPkt++;
                                   1567 ;	src\usbhost.c:405: for (i = 0; i != sizeof(USB_SETUP_REQ); i++)
      000487 0D               [12] 1568 	inc	r5
      000488 BD 08 E2         [24] 1569 	cjne	r5,#0x08,00102$
                                   1570 ;	src\usbhost.c:410: }
      00048B 22               [24] 1571 	ret
                                   1572 ;------------------------------------------------------------
                                   1573 ;Allocation info for local variables in function 'CtrlGetDeviceDescr'
                                   1574 ;------------------------------------------------------------
                                   1575 ;s                         Allocated to registers r6 
                                   1576 ;len                       Allocated with name '_CtrlGetDeviceDescr_len_10000_154'
                                   1577 ;------------------------------------------------------------
                                   1578 ;	src\usbhost.c:420: uint8_t CtrlGetDeviceDescr(void)
                                   1579 ;	-----------------------------------------
                                   1580 ;	 function CtrlGetDeviceDescr
                                   1581 ;	-----------------------------------------
      00048C                       1582 _CtrlGetDeviceDescr:
                                   1583 ;	src\usbhost.c:424: UsbDevEndp0Size = DEFAULT_ENDP0_SIZE;
      00048C 90r00r00         [24] 1584 	mov	dptr,#_UsbDevEndp0Size
      00048F 74 08            [12] 1585 	mov	a,#0x08
      000491 F0               [24] 1586 	movx	@dptr,a
                                   1587 ;	src\usbhost.c:425: CopySetupReqPkg(SetupGetDevDescr);
      000492 90r00r00         [24] 1588 	mov	dptr,#_SetupGetDevDescr
      000495 12r04r67         [24] 1589 	lcall	_CopySetupReqPkg
                                   1590 ;	src\usbhost.c:426: s = HostCtrlTransfer(Com_Buffer, (uint8_t *)&len); // 执行控制传输
      000498 75*05r0E         [24] 1591 	mov	_HostCtrlTransfer_PARM_2,#_CtrlGetDeviceDescr_len_10000_154
      00049B 75*06 00         [24] 1592 	mov	(_HostCtrlTransfer_PARM_2 + 1),#0x00
      00049E 75*07 40         [24] 1593 	mov	(_HostCtrlTransfer_PARM_2 + 2),#0x40
      0004A1 90r00r00         [24] 1594 	mov	dptr,#_Com_Buffer
      0004A4 12r02r31         [24] 1595 	lcall	_HostCtrlTransfer
                                   1596 ;	src\usbhost.c:427: if (s != ERR_SUCCESS)
      0004A7 E5 82            [12] 1597 	mov	a,dpl
      0004A9 FE               [12] 1598 	mov	r6,a
      0004AA 60 03            [24] 1599 	jz	00102$
                                   1600 ;	src\usbhost.c:429: return (s);
      0004AC 8E 82            [24] 1601 	mov	dpl, r6
      0004AE 22               [24] 1602 	ret
      0004AF                       1603 00102$:
                                   1604 ;	src\usbhost.c:431: UsbDevEndp0Size = ((PXUSB_DEV_DESCR)Com_Buffer)->bMaxPacketSize0; // 端点0最大包长度,这是简化处理,正常应该先获取前8字节后立即更新UsbDevEndp0Size再继续
      0004AF 90r00r07         [24] 1605 	mov	dptr,#(_Com_Buffer + 0x0007)
      0004B2 E0               [24] 1606 	movx	a,@dptr
      0004B3 90r00r00         [24] 1607 	mov	dptr,#_UsbDevEndp0Size
      0004B6 F0               [24] 1608 	movx	@dptr,a
                                   1609 ;	src\usbhost.c:432: if (len < ((PUSB_SETUP_REQ)SetupGetDevDescr)->wLengthL)
      0004B7 90r00r06         [24] 1610 	mov	dptr,#(_SetupGetDevDescr + 0x0006)
      0004BA E4               [12] 1611 	clr	a
      0004BB 93               [24] 1612 	movc	a,@a+dptr
      0004BC FF               [12] 1613 	mov	r7,a
      0004BD C3               [12] 1614 	clr	c
      0004BE E5*0E            [12] 1615 	mov	a,_CtrlGetDeviceDescr_len_10000_154
      0004C0 9F               [12] 1616 	subb	a,r7
      0004C1 50 04            [24] 1617 	jnc	00104$
                                   1618 ;	src\usbhost.c:434: return (ERR_USB_BUF_OVER); // 描述符长度错误
      0004C3 75 82 17         [24] 1619 	mov	dpl, #0x17
      0004C6 22               [24] 1620 	ret
      0004C7                       1621 00104$:
                                   1622 ;	src\usbhost.c:436: return (ERR_SUCCESS);
      0004C7 75 82 00         [24] 1623 	mov	dpl, #0x00
                                   1624 ;	src\usbhost.c:437: }
      0004CA 22               [24] 1625 	ret
                                   1626 ;------------------------------------------------------------
                                   1627 ;Allocation info for local variables in function 'CtrlGetConfigDescr'
                                   1628 ;------------------------------------------------------------
                                   1629 ;s                         Allocated to registers r7 
                                   1630 ;len                       Allocated with name '_CtrlGetConfigDescr_len_10000_158'
                                   1631 ;------------------------------------------------------------
                                   1632 ;	src\usbhost.c:447: uint8_t CtrlGetConfigDescr(void)
                                   1633 ;	-----------------------------------------
                                   1634 ;	 function CtrlGetConfigDescr
                                   1635 ;	-----------------------------------------
      0004CB                       1636 _CtrlGetConfigDescr:
                                   1637 ;	src\usbhost.c:450: CopySetupReqPkg(SetupGetCfgDescr);
      0004CB 90r00r00         [24] 1638 	mov	dptr,#_SetupGetCfgDescr
      0004CE 12r04r67         [24] 1639 	lcall	_CopySetupReqPkg
                                   1640 ;	src\usbhost.c:451: s = HostCtrlTransfer(Com_Buffer, (uint8_t *)&len); // 执行控制传输
      0004D1 75*05r0F         [24] 1641 	mov	_HostCtrlTransfer_PARM_2,#_CtrlGetConfigDescr_len_10000_158
      0004D4 75*06 00         [24] 1642 	mov	(_HostCtrlTransfer_PARM_2 + 1),#0x00
      0004D7 75*07 40         [24] 1643 	mov	(_HostCtrlTransfer_PARM_2 + 2),#0x40
      0004DA 90r00r00         [24] 1644 	mov	dptr,#_Com_Buffer
      0004DD 12r02r31         [24] 1645 	lcall	_HostCtrlTransfer
                                   1646 ;	src\usbhost.c:452: if (s != ERR_SUCCESS)
      0004E0 E5 82            [12] 1647 	mov	a,dpl
      0004E2 FF               [12] 1648 	mov	r7,a
      0004E3 60 03            [24] 1649 	jz	00102$
                                   1650 ;	src\usbhost.c:454: return (s);
      0004E5 8F 82            [24] 1651 	mov	dpl, r7
      0004E7 22               [24] 1652 	ret
      0004E8                       1653 00102$:
                                   1654 ;	src\usbhost.c:457: len = ((PXUSB_CFG_DESCR)Com_Buffer)->wTotalLengthL;
      0004E8 90r00r02         [24] 1655 	mov	dptr,#(_Com_Buffer + 0x0002)
      0004EB E0               [24] 1656 	movx	a,@dptr
      0004EC F5*0F            [12] 1657 	mov	_CtrlGetConfigDescr_len_10000_158,a
                                   1658 ;	src\usbhost.c:458: CopySetupReqPkg(SetupGetCfgDescr);
      0004EE 90r00r00         [24] 1659 	mov	dptr,#_SetupGetCfgDescr
      0004F1 12r04r67         [24] 1660 	lcall	_CopySetupReqPkg
                                   1661 ;	src\usbhost.c:459: pSetupReq->wLengthL = len;                         // 完整配置描述符的总长度
      0004F4 90r00r06         [24] 1662 	mov	dptr,#(_TxBuffer + 0x0006)
      0004F7 E5*0F            [12] 1663 	mov	a,_CtrlGetConfigDescr_len_10000_158
      0004F9 F0               [24] 1664 	movx	@dptr,a
                                   1665 ;	src\usbhost.c:460: s = HostCtrlTransfer(Com_Buffer, (uint8_t *)&len); // 执行控制传输
      0004FA 75*05r0F         [24] 1666 	mov	_HostCtrlTransfer_PARM_2,#_CtrlGetConfigDescr_len_10000_158
      0004FD 75*06 00         [24] 1667 	mov	(_HostCtrlTransfer_PARM_2 + 1),#0x00
      000500 75*07 40         [24] 1668 	mov	(_HostCtrlTransfer_PARM_2 + 2),#0x40
      000503 90r00r00         [24] 1669 	mov	dptr,#_Com_Buffer
      000506 12r02r31         [24] 1670 	lcall	_HostCtrlTransfer
                                   1671 ;	src\usbhost.c:461: if (s != ERR_SUCCESS)
      000509 E5 82            [12] 1672 	mov	a,dpl
      00050B FF               [12] 1673 	mov	r7,a
      00050C 60 03            [24] 1674 	jz	00104$
                                   1675 ;	src\usbhost.c:463: return (s);
      00050E 8F 82            [24] 1676 	mov	dpl, r7
      000510 22               [24] 1677 	ret
      000511                       1678 00104$:
                                   1679 ;	src\usbhost.c:465: return (ERR_SUCCESS);
      000511 75 82 00         [24] 1680 	mov	dpl, #0x00
                                   1681 ;	src\usbhost.c:466: }
      000514 22               [24] 1682 	ret
                                   1683 ;------------------------------------------------------------
                                   1684 ;Allocation info for local variables in function 'CtrlSetUsbAddress'
                                   1685 ;------------------------------------------------------------
                                   1686 ;addr                      Allocated to registers r7 
                                   1687 ;s                         Allocated to registers r5 
                                   1688 ;------------------------------------------------------------
                                   1689 ;	src\usbhost.c:475: uint8_t CtrlSetUsbAddress(uint8_t addr)
                                   1690 ;	-----------------------------------------
                                   1691 ;	 function CtrlSetUsbAddress
                                   1692 ;	-----------------------------------------
      000515                       1693 _CtrlSetUsbAddress:
      000515 AF 82            [24] 1694 	mov	r7, dpl
                                   1695 ;	src\usbhost.c:478: CopySetupReqPkg(SetupSetUsbAddr);
      000517 90r00r00         [24] 1696 	mov	dptr,#_SetupSetUsbAddr
      00051A C0 07            [24] 1697 	push	ar7
      00051C 12r04r67         [24] 1698 	lcall	_CopySetupReqPkg
      00051F D0 07            [24] 1699 	pop	ar7
                                   1700 ;	src\usbhost.c:479: pSetupReq->wValueL = addr;        // USB设备地址
      000521 90r00r02         [24] 1701 	mov	dptr,#(_TxBuffer + 0x0002)
      000524 EF               [12] 1702 	mov	a,r7
      000525 F0               [24] 1703 	movx	@dptr,a
                                   1704 ;	src\usbhost.c:480: s = HostCtrlTransfer(NULL, NULL); // 执行控制传输
      000526 E4               [12] 1705 	clr	a
      000527 F5*05            [12] 1706 	mov	_HostCtrlTransfer_PARM_2,a
      000529 F5*06            [12] 1707 	mov	(_HostCtrlTransfer_PARM_2 + 1),a
      00052B F5*07            [12] 1708 	mov	(_HostCtrlTransfer_PARM_2 + 2),a
      00052D 90 00 00         [24] 1709 	mov	dptr,#0x0000
      000530 C0 07            [24] 1710 	push	ar7
      000532 12r02r31         [24] 1711 	lcall	_HostCtrlTransfer
      000535 AE 82            [24] 1712 	mov	r6, dpl
      000537 D0 07            [24] 1713 	pop	ar7
                                   1714 ;	src\usbhost.c:481: if (s != ERR_SUCCESS)
      000539 EE               [12] 1715 	mov	a,r6
      00053A FD               [12] 1716 	mov	r5,a
      00053B 60 03            [24] 1717 	jz	00102$
                                   1718 ;	src\usbhost.c:483: return (s);
      00053D 8D 82            [24] 1719 	mov	dpl, r5
      00053F 22               [24] 1720 	ret
      000540                       1721 00102$:
                                   1722 ;	src\usbhost.c:485: SetHostUsbAddr(addr); // 设置USB主机当前操作的USB设备地址
      000540 8F 82            [24] 1723 	mov	dpl, r7
      000542 12r00r3B         [24] 1724 	lcall	_SetHostUsbAddr
                                   1725 ;	src\usbhost.c:486: mDelaymS(10);         // 等待USB设备完成操作
      000545 90 00 0A         [24] 1726 	mov	dptr,#0x000a
      000548 12r00r00         [24] 1727 	lcall	_mDelaymS
                                   1728 ;	src\usbhost.c:487: return (ERR_SUCCESS);
      00054B 75 82 00         [24] 1729 	mov	dpl, #0x00
                                   1730 ;	src\usbhost.c:488: }
      00054E 22               [24] 1731 	ret
                                   1732 ;------------------------------------------------------------
                                   1733 ;Allocation info for local variables in function 'CtrlSetUsbConfig'
                                   1734 ;------------------------------------------------------------
                                   1735 ;cfg                       Allocated to registers r7 
                                   1736 ;------------------------------------------------------------
                                   1737 ;	src\usbhost.c:497: uint8_t CtrlSetUsbConfig(uint8_t cfg)
                                   1738 ;	-----------------------------------------
                                   1739 ;	 function CtrlSetUsbConfig
                                   1740 ;	-----------------------------------------
      00054F                       1741 _CtrlSetUsbConfig:
      00054F AF 82            [24] 1742 	mov	r7, dpl
                                   1743 ;	src\usbhost.c:499: CopySetupReqPkg(SetupSetUsbConfig);
      000551 90r00r00         [24] 1744 	mov	dptr,#_SetupSetUsbConfig
      000554 C0 07            [24] 1745 	push	ar7
      000556 12r04r67         [24] 1746 	lcall	_CopySetupReqPkg
      000559 D0 07            [24] 1747 	pop	ar7
                                   1748 ;	src\usbhost.c:500: pSetupReq->wValueL = cfg;              // USB设备配置
      00055B 90r00r02         [24] 1749 	mov	dptr,#(_TxBuffer + 0x0002)
      00055E EF               [12] 1750 	mov	a,r7
      00055F F0               [24] 1751 	movx	@dptr,a
                                   1752 ;	src\usbhost.c:501: return (HostCtrlTransfer(NULL, NULL)); // 执行控制传输
      000560 E4               [12] 1753 	clr	a
      000561 F5*05            [12] 1754 	mov	_HostCtrlTransfer_PARM_2,a
      000563 F5*06            [12] 1755 	mov	(_HostCtrlTransfer_PARM_2 + 1),a
      000565 F5*07            [12] 1756 	mov	(_HostCtrlTransfer_PARM_2 + 2),a
      000567 90 00 00         [24] 1757 	mov	dptr,#0x0000
                                   1758 ;	src\usbhost.c:502: }
      00056A 02r02r31         [24] 1759 	ljmp	_HostCtrlTransfer
                                   1760 ;------------------------------------------------------------
                                   1761 ;Allocation info for local variables in function 'CtrlClearEndpStall'
                                   1762 ;------------------------------------------------------------
                                   1763 ;endp                      Allocated to registers r7 
                                   1764 ;------------------------------------------------------------
                                   1765 ;	src\usbhost.c:511: uint8_t CtrlClearEndpStall(uint8_t endp)
                                   1766 ;	-----------------------------------------
                                   1767 ;	 function CtrlClearEndpStall
                                   1768 ;	-----------------------------------------
      00056D                       1769 _CtrlClearEndpStall:
      00056D AF 82            [24] 1770 	mov	r7, dpl
                                   1771 ;	src\usbhost.c:513: CopySetupReqPkg(SetupClrEndpStall);    // 清除端点的错误
      00056F 90r00r00         [24] 1772 	mov	dptr,#_SetupClrEndpStall
      000572 C0 07            [24] 1773 	push	ar7
      000574 12r04r67         [24] 1774 	lcall	_CopySetupReqPkg
      000577 D0 07            [24] 1775 	pop	ar7
                                   1776 ;	src\usbhost.c:514: pSetupReq->wIndexL = endp;             // 端点地址
      000579 90r00r04         [24] 1777 	mov	dptr,#(_TxBuffer + 0x0004)
      00057C EF               [12] 1778 	mov	a,r7
      00057D F0               [24] 1779 	movx	@dptr,a
                                   1780 ;	src\usbhost.c:515: return (HostCtrlTransfer(NULL, NULL)); // 执行控制传输
      00057E E4               [12] 1781 	clr	a
      00057F F5*05            [12] 1782 	mov	_HostCtrlTransfer_PARM_2,a
      000581 F5*06            [12] 1783 	mov	(_HostCtrlTransfer_PARM_2 + 1),a
      000583 F5*07            [12] 1784 	mov	(_HostCtrlTransfer_PARM_2 + 2),a
      000585 90 00 00         [24] 1785 	mov	dptr,#0x0000
                                   1786 ;	src\usbhost.c:516: }
      000588 02r02r31         [24] 1787 	ljmp	_HostCtrlTransfer
                                   1788 ;------------------------------------------------------------
                                   1789 ;Allocation info for local variables in function 'CtrlSetUsbInterface'
                                   1790 ;------------------------------------------------------------
                                   1791 ;cfg                       Allocated to registers r7 
                                   1792 ;------------------------------------------------------------
                                   1793 ;	src\usbhost.c:526: uint8_t CtrlSetUsbInterface(uint8_t cfg)
                                   1794 ;	-----------------------------------------
                                   1795 ;	 function CtrlSetUsbInterface
                                   1796 ;	-----------------------------------------
      00058B                       1797 _CtrlSetUsbInterface:
      00058B AF 82            [24] 1798 	mov	r7, dpl
                                   1799 ;	src\usbhost.c:528: CopySetupReqPkg(SetupSetUsbInterface);
      00058D 90r00r00         [24] 1800 	mov	dptr,#_SetupSetUsbInterface
      000590 C0 07            [24] 1801 	push	ar7
      000592 12r04r67         [24] 1802 	lcall	_CopySetupReqPkg
      000595 D0 07            [24] 1803 	pop	ar7
                                   1804 ;	src\usbhost.c:529: pSetupReq->wValueL = cfg;              // USB设备配置
      000597 90r00r02         [24] 1805 	mov	dptr,#(_TxBuffer + 0x0002)
      00059A EF               [12] 1806 	mov	a,r7
      00059B F0               [24] 1807 	movx	@dptr,a
                                   1808 ;	src\usbhost.c:530: return (HostCtrlTransfer(NULL, NULL)); // 执行控制传输
      00059C E4               [12] 1809 	clr	a
      00059D F5*05            [12] 1810 	mov	_HostCtrlTransfer_PARM_2,a
      00059F F5*06            [12] 1811 	mov	(_HostCtrlTransfer_PARM_2 + 1),a
      0005A1 F5*07            [12] 1812 	mov	(_HostCtrlTransfer_PARM_2 + 2),a
      0005A3 90 00 00         [24] 1813 	mov	dptr,#0x0000
                                   1814 ;	src\usbhost.c:531: }
      0005A6 02r02r31         [24] 1815 	ljmp	_HostCtrlTransfer
                                   1816 ;------------------------------------------------------------
                                   1817 ;Allocation info for local variables in function 'CtrlGetHIDDeviceReport'
                                   1818 ;------------------------------------------------------------
                                   1819 ;infc                      Allocated to registers r7 
                                   1820 ;s                         Allocated to registers r7 
                                   1821 ;len                       Allocated with name '_CtrlGetHIDDeviceReport_len_10000_171'
                                   1822 ;------------------------------------------------------------
                                   1823 ;	src\usbhost.c:541: uint8_t CtrlGetHIDDeviceReport(uint8_t infc)
                                   1824 ;	-----------------------------------------
                                   1825 ;	 function CtrlGetHIDDeviceReport
                                   1826 ;	-----------------------------------------
      0005A9                       1827 _CtrlGetHIDDeviceReport:
      0005A9 AF 82            [24] 1828 	mov	r7, dpl
                                   1829 ;	src\usbhost.c:546: CopySetupReqPkg(SetupSetHIDIdle);
      0005AB 90r00r00         [24] 1830 	mov	dptr,#_SetupSetHIDIdle
      0005AE C0 07            [24] 1831 	push	ar7
      0005B0 12r04r67         [24] 1832 	lcall	_CopySetupReqPkg
      0005B3 D0 07            [24] 1833 	pop	ar7
                                   1834 ;	src\usbhost.c:547: TxBuffer[4] = infc;
      0005B5 90r00r04         [24] 1835 	mov	dptr,#(_TxBuffer + 0x0004)
      0005B8 EF               [12] 1836 	mov	a,r7
      0005B9 F0               [24] 1837 	movx	@dptr,a
                                   1838 ;	src\usbhost.c:548: s = HostCtrlTransfer(Com_Buffer, (uint8_t *)&len); // 执行控制传输
      0005BA 75*05r10         [24] 1839 	mov	_HostCtrlTransfer_PARM_2,#_CtrlGetHIDDeviceReport_len_10000_171
      0005BD 75*06 00         [24] 1840 	mov	(_HostCtrlTransfer_PARM_2 + 1),#0x00
      0005C0 75*07 40         [24] 1841 	mov	(_HostCtrlTransfer_PARM_2 + 2),#0x40
      0005C3 90r00r00         [24] 1842 	mov	dptr,#_Com_Buffer
      0005C6 C0 07            [24] 1843 	push	ar7
      0005C8 12r02r31         [24] 1844 	lcall	_HostCtrlTransfer
      0005CB AE 82            [24] 1845 	mov	r6, dpl
      0005CD D0 07            [24] 1846 	pop	ar7
                                   1847 ;	src\usbhost.c:549: if (s != ERR_SUCCESS)
      0005CF EE               [12] 1848 	mov	a,r6
      0005D0 60 03            [24] 1849 	jz	00102$
                                   1850 ;	src\usbhost.c:551: return (s);
      0005D2 8E 82            [24] 1851 	mov	dpl, r6
      0005D4 22               [24] 1852 	ret
      0005D5                       1853 00102$:
                                   1854 ;	src\usbhost.c:554: CopySetupReqPkg(SetupGetHIDDevReport);
      0005D5 90r00r00         [24] 1855 	mov	dptr,#_SetupGetHIDDevReport
      0005D8 C0 07            [24] 1856 	push	ar7
      0005DA 12r04r67         [24] 1857 	lcall	_CopySetupReqPkg
      0005DD D0 07            [24] 1858 	pop	ar7
                                   1859 ;	src\usbhost.c:555: TxBuffer[4] = infc;
      0005DF 90r00r04         [24] 1860 	mov	dptr,#(_TxBuffer + 0x0004)
      0005E2 EF               [12] 1861 	mov	a,r7
      0005E3 F0               [24] 1862 	movx	@dptr,a
                                   1863 ;	src\usbhost.c:556: s = HostCtrlTransfer(Com_Buffer, (uint8_t *)&len); // 执行控制传输
      0005E4 75*05r10         [24] 1864 	mov	_HostCtrlTransfer_PARM_2,#_CtrlGetHIDDeviceReport_len_10000_171
      0005E7 75*06 00         [24] 1865 	mov	(_HostCtrlTransfer_PARM_2 + 1),#0x00
      0005EA 75*07 40         [24] 1866 	mov	(_HostCtrlTransfer_PARM_2 + 2),#0x40
      0005ED 90r00r00         [24] 1867 	mov	dptr,#_Com_Buffer
      0005F0 12r02r31         [24] 1868 	lcall	_HostCtrlTransfer
                                   1869 ;	src\usbhost.c:557: if (s != ERR_SUCCESS)
      0005F3 E5 82            [12] 1870 	mov	a,dpl
      0005F5 FF               [12] 1871 	mov	r7,a
      0005F6 60 03            [24] 1872 	jz	00104$
                                   1873 ;	src\usbhost.c:559: return (s);
      0005F8 8F 82            [24] 1874 	mov	dpl, r7
      0005FA 22               [24] 1875 	ret
      0005FB                       1876 00104$:
                                   1877 ;	src\usbhost.c:562: return (ERR_SUCCESS);
      0005FB 75 82 00         [24] 1878 	mov	dpl, #0x00
                                   1879 ;	src\usbhost.c:563: }
      0005FE 22               [24] 1880 	ret
                                   1881 ;------------------------------------------------------------
                                   1882 ;Allocation info for local variables in function 'AnalyzeHidIntEndp'
                                   1883 ;------------------------------------------------------------
                                   1884 ;buf                       Allocated to registers r6 r7 
                                   1885 ;i                         Allocated to registers r5 
                                   1886 ;s                         Allocated to registers r4 
                                   1887 ;l                         Allocated to registers r3 
                                   1888 ;------------------------------------------------------------
                                   1889 ;	src\usbhost.c:572: uint8_t AnalyzeHidIntEndp(__xdata uint8_t *buf)
                                   1890 ;	-----------------------------------------
                                   1891 ;	 function AnalyzeHidIntEndp
                                   1892 ;	-----------------------------------------
      0005FF                       1893 _AnalyzeHidIntEndp:
      0005FF AE 82            [24] 1894 	mov	r6, dpl
      000601 AF 83            [24] 1895 	mov	r7, dph
                                   1896 ;	src\usbhost.c:577: memset(ThisUsbDev.GpVar, 0, sizeof(ThisUsbDev.GpVar)); // 清空数组
      000603 75*00 00         [24] 1897 	mov	_memset_PARM_2,#0x00
      000606 75*00 04         [24] 1898 	mov	_memset_PARM_3,#0x04
      000609 75*01 00         [24] 1899 	mov	(_memset_PARM_3 + 1),#0x00
      00060C 90r00r08         [24] 1900 	mov	dptr,#(_ThisUsbDev + 0x0008)
      00060F 75 F0 00         [24] 1901 	mov	b, #0x00
      000612 C0 07            [24] 1902 	push	ar7
      000614 C0 06            [24] 1903 	push	ar6
      000616 12r00r00         [24] 1904 	lcall	_memset
      000619 D0 06            [24] 1905 	pop	ar6
      00061B D0 07            [24] 1906 	pop	ar7
                                   1907 ;	src\usbhost.c:579: for (i = 0; i < ((PXUSB_CFG_DESCR)buf)->wTotalLengthL; i += l) // 搜索中断端点描述符,跳过配置描述符和接口描述符
      00061D 7D 00            [12] 1908 	mov	r5,#0x00
      00061F 7C 00            [12] 1909 	mov	r4,#0x00
      000621                       1910 00111$:
      000621 8E 02            [24] 1911 	mov	ar2,r6
      000623 8F 03            [24] 1912 	mov	ar3,r7
      000625 8A 82            [24] 1913 	mov	dpl,r2
      000627 8B 83            [24] 1914 	mov	dph,r3
      000629 A3               [24] 1915 	inc	dptr
      00062A A3               [24] 1916 	inc	dptr
      00062B E0               [24] 1917 	movx	a,@dptr
      00062C FB               [12] 1918 	mov	r3,a
      00062D C3               [12] 1919 	clr	c
      00062E ED               [12] 1920 	mov	a,r5
      00062F 9B               [12] 1921 	subb	a,r3
      000630 50 68            [24] 1922 	jnc	00109$
                                   1923 ;	src\usbhost.c:581: if (((PXUSB_ENDP_DESCR)(buf + i))->bDescriptorType == USB_DESCR_TYP_ENDP                         // 是端点描述符
      000632 ED               [12] 1924 	mov	a,r5
      000633 2E               [12] 1925 	add	a, r6
      000634 FA               [12] 1926 	mov	r2,a
      000635 E4               [12] 1927 	clr	a
      000636 3F               [12] 1928 	addc	a, r7
      000637 FB               [12] 1929 	mov	r3,a
      000638 8A 00            [24] 1930 	mov	ar0,r2
      00063A 8B 01            [24] 1931 	mov	ar1,r3
      00063C 88 82            [24] 1932 	mov	dpl,r0
      00063E 89 83            [24] 1933 	mov	dph,r1
      000640 A3               [24] 1934 	inc	dptr
      000641 E0               [24] 1935 	movx	a,@dptr
      000642 F9               [12] 1936 	mov	r1,a
      000643 B9 05 40         [24] 1937 	cjne	r1,#0x05,00104$
                                   1938 ;	src\usbhost.c:582: && (((PXUSB_ENDP_DESCR)(buf + i))->bmAttributes & USB_ENDP_TYPE_MASK) == USB_ENDP_TYPE_INTER // 是中断端点
      000646 8A 00            [24] 1939 	mov	ar0,r2
      000648 8B 01            [24] 1940 	mov	ar1,r3
      00064A 88 82            [24] 1941 	mov	dpl,r0
      00064C 89 83            [24] 1942 	mov	dph,r1
      00064E A3               [24] 1943 	inc	dptr
      00064F A3               [24] 1944 	inc	dptr
      000650 A3               [24] 1945 	inc	dptr
      000651 E0               [24] 1946 	movx	a,@dptr
      000652 F9               [12] 1947 	mov	r1,a
      000653 53 01 03         [24] 1948 	anl	ar1,#0x03
      000656 B9 03 2D         [24] 1949 	cjne	r1,#0x03,00104$
                                   1950 ;	src\usbhost.c:583: && (((PXUSB_ENDP_DESCR)(buf + i))->bEndpointAddress & USB_ENDP_DIR_MASK))                    // 是IN端点
      000659 8A 00            [24] 1951 	mov	ar0,r2
      00065B 8B 01            [24] 1952 	mov	ar1,r3
      00065D 88 82            [24] 1953 	mov	dpl,r0
      00065F 89 83            [24] 1954 	mov	dph,r1
      000661 A3               [24] 1955 	inc	dptr
      000662 A3               [24] 1956 	inc	dptr
      000663 E0               [24] 1957 	movx	a,@dptr
      000664 30 E7 1F         [24] 1958 	jnb	acc.7,00104$
                                   1959 ;	src\usbhost.c:585: ThisUsbDev.GpVar[s] = ((PXUSB_ENDP_DESCR)(buf + i))->bEndpointAddress & USB_ENDP_ADDR_MASK;  // 中断端点的地址，可以根据需要保存wMaxPacketSize和bInterval
      000667 EC               [12] 1960 	mov	a,r4
      000668 24r08            [12] 1961 	add	a, #(_ThisUsbDev + 0x0008)
      00066A F8               [12] 1962 	mov	r0,a
      00066B E4               [12] 1963 	clr	a
      00066C 34s00            [12] 1964 	addc	a, #((_ThisUsbDev + 0x0008) >> 8)
      00066E F9               [12] 1965 	mov	r1,a
      00066F 8A 82            [24] 1966 	mov	dpl,r2
      000671 8B 83            [24] 1967 	mov	dph,r3
      000673 A3               [24] 1968 	inc	dptr
      000674 A3               [24] 1969 	inc	dptr
      000675 E0               [24] 1970 	movx	a,@dptr
      000676 FB               [12] 1971 	mov	r3,a
      000677 53 03 0F         [24] 1972 	anl	ar3,#0x0f
      00067A 88 82            [24] 1973 	mov	dpl,r0
      00067C 89 83            [24] 1974 	mov	dph,r1
      00067E EB               [12] 1975 	mov	a,r3
      00067F F0               [24] 1976 	movx	@dptr,a
                                   1977 ;	src\usbhost.c:589: s++;
      000680 0C               [12] 1978 	inc	r4
                                   1979 ;	src\usbhost.c:590: if (s >= 4)
      000681 BC 04 00         [24] 1980 	cjne	r4,#0x04,00158$
      000684                       1981 00158$:
      000684 50 14            [24] 1982 	jnc	00109$
                                   1983 ;	src\usbhost.c:591: break; // Only analyze 4 endpoints
      000686                       1984 00104$:
                                   1985 ;	src\usbhost.c:593: l = ((PXUSB_ENDP_DESCR)(buf + i))->bLength; // 当前描述符长度,跳过
      000686 ED               [12] 1986 	mov	a,r5
      000687 2E               [12] 1987 	add	a, r6
      000688 F5 82            [12] 1988 	mov	dpl,a
      00068A E4               [12] 1989 	clr	a
      00068B 3F               [12] 1990 	addc	a, r7
      00068C F5 83            [12] 1991 	mov	dph,a
      00068E E0               [24] 1992 	movx	a,@dptr
                                   1993 ;	src\usbhost.c:594: if (l > 16)
      00068F FB               [12] 1994 	mov  r3,a
      000690 24 EF            [12] 1995 	add	a,#0xff - 0x10
      000692 40 06            [24] 1996 	jc	00109$
                                   1997 ;	src\usbhost.c:579: for (i = 0; i < ((PXUSB_CFG_DESCR)buf)->wTotalLengthL; i += l) // 搜索中断端点描述符,跳过配置描述符和接口描述符
      000694 EB               [12] 1998 	mov	a,r3
      000695 2D               [12] 1999 	add	a, r5
      000696 FD               [12] 2000 	mov	r5,a
      000697 02r06r21         [24] 2001 	ljmp	00111$
      00069A                       2002 00109$:
                                   2003 ;	src\usbhost.c:602: return (s);
      00069A 8C 82            [24] 2004 	mov	dpl, r4
                                   2005 ;	src\usbhost.c:603: }
      00069C 22               [24] 2006 	ret
                                   2007 ;------------------------------------------------------------
                                   2008 ;Allocation info for local variables in function 'AnalyzeBulkEndp'
                                   2009 ;------------------------------------------------------------
                                   2010 ;buf                       Allocated with name '_AnalyzeBulkEndp_buf_10000_180'
                                   2011 ;i                         Allocated to registers r3 
                                   2012 ;s1                        Allocated with name '_AnalyzeBulkEndp_s1_10000_181'
                                   2013 ;s2                        Allocated with name '_AnalyzeBulkEndp_s2_10000_181'
                                   2014 ;l                         Allocated to registers r7 
                                   2015 ;------------------------------------------------------------
                                   2016 ;	src\usbhost.c:612: uint8_t AnalyzeBulkEndp(__xdata uint8_t *buf)
                                   2017 ;	-----------------------------------------
                                   2018 ;	 function AnalyzeBulkEndp
                                   2019 ;	-----------------------------------------
      00069D                       2020 _AnalyzeBulkEndp:
      00069D 85 82*11         [24] 2021 	mov	_AnalyzeBulkEndp_buf_10000_180,dpl
      0006A0 85 83*12         [24] 2022 	mov	(_AnalyzeBulkEndp_buf_10000_180 + 1),dph
                                   2023 ;	src\usbhost.c:615: s1 = 0;
      0006A3 75*13 00         [24] 2024 	mov	_AnalyzeBulkEndp_s1_10000_181,#0x00
                                   2025 ;	src\usbhost.c:616: s2 = 2;
      0006A6 75*14 02         [24] 2026 	mov	_AnalyzeBulkEndp_s2_10000_181,#0x02
                                   2027 ;	src\usbhost.c:618: memset(ThisUsbDev.GpVar, 0, sizeof(ThisUsbDev.GpVar)); // 清空数组
      0006A9 75*00 00         [24] 2028 	mov	_memset_PARM_2,#0x00
      0006AC 75*00 04         [24] 2029 	mov	_memset_PARM_3,#0x04
      0006AF 75*01 00         [24] 2030 	mov	(_memset_PARM_3 + 1),#0x00
      0006B2 90r00r08         [24] 2031 	mov	dptr,#(_ThisUsbDev + 0x0008)
      0006B5 75 F0 00         [24] 2032 	mov	b, #0x00
      0006B8 12r00r00         [24] 2033 	lcall	_memset
                                   2034 ;	src\usbhost.c:620: for (i = 0; i < ((PXUSB_CFG_DESCR)buf)->wTotalLengthL; i += l) // 搜索中断端点描述符,跳过配置描述符和接口描述符
      0006BB 7B 00            [12] 2035 	mov	r3,#0x00
      0006BD                       2036 00115$:
      0006BD A9*11            [24] 2037 	mov	r1,_AnalyzeBulkEndp_buf_10000_180
      0006BF AA*12            [24] 2038 	mov	r2,(_AnalyzeBulkEndp_buf_10000_180 + 1)
      0006C1 89 82            [24] 2039 	mov	dpl,r1
      0006C3 8A 83            [24] 2040 	mov	dph,r2
      0006C5 A3               [24] 2041 	inc	dptr
      0006C6 A3               [24] 2042 	inc	dptr
      0006C7 E0               [24] 2043 	movx	a,@dptr
      0006C8 FA               [12] 2044 	mov	r2,a
      0006C9 C3               [12] 2045 	clr	c
      0006CA EB               [12] 2046 	mov	a,r3
      0006CB 9A               [12] 2047 	subb	a,r2
      0006CC 40 03            [24] 2048 	jc	00167$
      0006CE 02r07r73         [24] 2049 	ljmp	00113$
      0006D1                       2050 00167$:
                                   2051 ;	src\usbhost.c:622: if ((((PXUSB_ENDP_DESCR)(buf + i))->bDescriptorType == USB_DESCR_TYP_ENDP)                         // 是端点描述符
      0006D1 EB               [12] 2052 	mov	a,r3
      0006D2 25*11            [12] 2053 	add	a, _AnalyzeBulkEndp_buf_10000_180
      0006D4 F9               [12] 2054 	mov	r1,a
      0006D5 E4               [12] 2055 	clr	a
      0006D6 35*12            [12] 2056 	addc	a, (_AnalyzeBulkEndp_buf_10000_180 + 1)
      0006D8 FA               [12] 2057 	mov	r2,a
      0006D9 89 00            [24] 2058 	mov	ar0,r1
      0006DB 8A 04            [24] 2059 	mov	ar4,r2
      0006DD 88 82            [24] 2060 	mov	dpl,r0
      0006DF 8C 83            [24] 2061 	mov	dph,r4
      0006E1 A3               [24] 2062 	inc	dptr
      0006E2 E0               [24] 2063 	movx	a,@dptr
      0006E3 FC               [12] 2064 	mov	r4,a
      0006E4 BC 05 02         [24] 2065 	cjne	r4,#0x05,00168$
      0006E7 80 03            [24] 2066 	sjmp	00169$
      0006E9                       2067 00168$:
      0006E9 02r07r5D         [24] 2068 	ljmp	00109$
      0006EC                       2069 00169$:
                                   2070 ;	src\usbhost.c:623: && ((((PXUSB_ENDP_DESCR)(buf + i))->bmAttributes & USB_ENDP_TYPE_MASK) == USB_ENDP_TYPE_BULK)) // 是中断端点
      0006EC 89 00            [24] 2071 	mov	ar0,r1
      0006EE 8A 04            [24] 2072 	mov	ar4,r2
      0006F0 88 82            [24] 2073 	mov	dpl,r0
      0006F2 8C 83            [24] 2074 	mov	dph,r4
      0006F4 A3               [24] 2075 	inc	dptr
      0006F5 A3               [24] 2076 	inc	dptr
      0006F6 A3               [24] 2077 	inc	dptr
      0006F7 E0               [24] 2078 	movx	a,@dptr
      0006F8 FC               [12] 2079 	mov	r4,a
      0006F9 53 04 03         [24] 2080 	anl	ar4,#0x03
      0006FC BC 02 5E         [24] 2081 	cjne	r4,#0x02,00109$
                                   2082 ;	src\usbhost.c:626: if (((PXUSB_ENDP_DESCR)(buf + i))->bEndpointAddress & USB_ENDP_DIR_MASK)
      0006FF 89 00            [24] 2083 	mov	ar0,r1
      000701 8A 04            [24] 2084 	mov	ar4,r2
      000703 88 82            [24] 2085 	mov	dpl,r0
      000705 8C 83            [24] 2086 	mov	dph,r4
      000707 A3               [24] 2087 	inc	dptr
      000708 A3               [24] 2088 	inc	dptr
      000709 E0               [24] 2089 	movx	a,@dptr
      00070A 30 E7 23         [24] 2090 	jnb	acc.7,00102$
                                   2091 ;	src\usbhost.c:627: ThisUsbDev.GpVar[s1++] = ((PXUSB_ENDP_DESCR)(buf + i))->bEndpointAddress & USB_ENDP_ADDR_MASK;
      00070D AC*13            [24] 2092 	mov	r4,_AnalyzeBulkEndp_s1_10000_181
      00070F 05*13            [12] 2093 	inc	_AnalyzeBulkEndp_s1_10000_181
      000711 EC               [12] 2094 	mov	a,r4
      000712 24r08            [12] 2095 	add	a, #(_ThisUsbDev + 0x0008)
      000714 F8               [12] 2096 	mov	r0,a
      000715 E4               [12] 2097 	clr	a
      000716 34s00            [12] 2098 	addc	a, #((_ThisUsbDev + 0x0008) >> 8)
      000718 FC               [12] 2099 	mov	r4,a
      000719 89 05            [24] 2100 	mov	ar5,r1
      00071B 8A 07            [24] 2101 	mov	ar7,r2
      00071D 8D 82            [24] 2102 	mov	dpl,r5
      00071F 8F 83            [24] 2103 	mov	dph,r7
      000721 A3               [24] 2104 	inc	dptr
      000722 A3               [24] 2105 	inc	dptr
      000723 E0               [24] 2106 	movx	a,@dptr
      000724 FF               [12] 2107 	mov	r7,a
      000725 53 07 0F         [24] 2108 	anl	ar7,#0x0f
      000728 88 82            [24] 2109 	mov	dpl,r0
      00072A 8C 83            [24] 2110 	mov	dph,r4
      00072C EF               [12] 2111 	mov	a,r7
      00072D F0               [24] 2112 	movx	@dptr,a
      00072E 80 1D            [24] 2113 	sjmp	00103$
      000730                       2114 00102$:
                                   2115 ;	src\usbhost.c:629: ThisUsbDev.GpVar[s2++] = ((PXUSB_ENDP_DESCR)(buf + i))->bEndpointAddress & USB_ENDP_ADDR_MASK;
      000730 AF*14            [24] 2116 	mov	r7,_AnalyzeBulkEndp_s2_10000_181
      000732 05*14            [12] 2117 	inc	_AnalyzeBulkEndp_s2_10000_181
      000734 EF               [12] 2118 	mov	a,r7
      000735 24r08            [12] 2119 	add	a, #(_ThisUsbDev + 0x0008)
      000737 FF               [12] 2120 	mov	r7,a
      000738 E4               [12] 2121 	clr	a
      000739 34s00            [12] 2122 	addc	a, #((_ThisUsbDev + 0x0008) >> 8)
      00073B FE               [12] 2123 	mov	r6,a
      00073C 89 82            [24] 2124 	mov	dpl,r1
      00073E 8A 83            [24] 2125 	mov	dph,r2
      000740 A3               [24] 2126 	inc	dptr
      000741 A3               [24] 2127 	inc	dptr
      000742 E0               [24] 2128 	movx	a,@dptr
      000743 FD               [12] 2129 	mov	r5,a
      000744 53 05 0F         [24] 2130 	anl	ar5,#0x0f
      000747 8F 82            [24] 2131 	mov	dpl,r7
      000749 8E 83            [24] 2132 	mov	dph,r6
      00074B ED               [12] 2133 	mov	a,r5
      00074C F0               [24] 2134 	movx	@dptr,a
      00074D                       2135 00103$:
                                   2136 ;	src\usbhost.c:631: if (s1 == 2)
      00074D 74 02            [12] 2137 	mov	a,#0x02
      00074F B5*13 03         [24] 2138 	cjne	a,_AnalyzeBulkEndp_s1_10000_181,00105$
                                   2139 ;	src\usbhost.c:632: s1 = 1;
      000752 75*13 01         [24] 2140 	mov	_AnalyzeBulkEndp_s1_10000_181,#0x01
      000755                       2141 00105$:
                                   2142 ;	src\usbhost.c:633: if (s2 == 4)
      000755 74 04            [12] 2143 	mov	a,#0x04
      000757 B5*14 03         [24] 2144 	cjne	a,_AnalyzeBulkEndp_s2_10000_181,00109$
                                   2145 ;	src\usbhost.c:634: s2 = 3;
      00075A 75*14 03         [24] 2146 	mov	_AnalyzeBulkEndp_s2_10000_181,#0x03
      00075D                       2147 00109$:
                                   2148 ;	src\usbhost.c:636: l = ((PXUSB_ENDP_DESCR)(buf + i))->bLength; // 当前描述符长度,跳过
      00075D EB               [12] 2149 	mov	a,r3
      00075E 25*11            [12] 2150 	add	a, _AnalyzeBulkEndp_buf_10000_180
      000760 F5 82            [12] 2151 	mov	dpl,a
      000762 E4               [12] 2152 	clr	a
      000763 35*12            [12] 2153 	addc	a, (_AnalyzeBulkEndp_buf_10000_180 + 1)
      000765 F5 83            [12] 2154 	mov	dph,a
      000767 E0               [24] 2155 	movx	a,@dptr
                                   2156 ;	src\usbhost.c:637: if (l > 16)
      000768 FF               [12] 2157 	mov  r7,a
      000769 24 EF            [12] 2158 	add	a,#0xff - 0x10
      00076B 40 06            [24] 2159 	jc	00113$
                                   2160 ;	src\usbhost.c:620: for (i = 0; i < ((PXUSB_CFG_DESCR)buf)->wTotalLengthL; i += l) // 搜索中断端点描述符,跳过配置描述符和接口描述符
      00076D EF               [12] 2161 	mov	a,r7
      00076E 2B               [12] 2162 	add	a, r3
      00076F FB               [12] 2163 	mov	r3,a
      000770 02r06rBD         [24] 2164 	ljmp	00115$
      000773                       2165 00113$:
                                   2166 ;	src\usbhost.c:642: return (0);
      000773 75 82 00         [24] 2167 	mov	dpl, #0x00
                                   2168 ;	src\usbhost.c:643: }
      000776 22               [24] 2169 	ret
                                   2170 ;------------------------------------------------------------
                                   2171 ;Allocation info for local variables in function 'InitRootDevice'
                                   2172 ;------------------------------------------------------------
                                   2173 ;t                         Allocated to registers r6 
                                   2174 ;i                         Allocated to registers r5 
                                   2175 ;s                         Allocated to registers r7 
                                   2176 ;cfg                       Allocated to registers r4 
                                   2177 ;dv_cls                    Allocated to registers r5 
                                   2178 ;if_cls                    Allocated to registers r5 
                                   2179 ;ifc                       Allocated to registers r3 
                                   2180 ;if_cls2                   Allocated to registers r1 
                                   2181 ;------------------------------------------------------------
                                   2182 ;	src\usbhost.c:652: uint8_t InitRootDevice(void)
                                   2183 ;	-----------------------------------------
                                   2184 ;	 function InitRootDevice
                                   2185 ;	-----------------------------------------
      000777                       2186 _InitRootDevice:
                                   2187 ;	src\usbhost.c:656: s = 0;
      000777 7F 00            [12] 2188 	mov	r7,#0x00
                                   2189 ;	src\usbhost.c:660: USBDevEnum:
      000779 7E 00            [12] 2190 	mov	r6,#0x00
                                   2191 ;	src\usbhost.c:661: for (i = 0; i < t; i++)
      00077B                       2192 00153$:
      00077B C3               [12] 2193 	clr	c
      00077C 74 0A            [12] 2194 	mov	a,#0x0a
      00077E 9E               [12] 2195 	subb	a,r6
      00077F E4               [12] 2196 	clr	a
      000780 33               [12] 2197 	rlc	a
      000781 FD               [12] 2198 	mov	r5,a
      000782 7C 00            [12] 2199 	mov	r4,#0x00
      000784                       2200 00141$:
      000784 C3               [12] 2201 	clr	c
      000785 EC               [12] 2202 	mov	a,r4
      000786 9E               [12] 2203 	subb	a,r6
      000787 50 1F            [24] 2204 	jnc	00104$
                                   2205 ;	src\usbhost.c:663: mDelaymS(100);
      000789 90 00 64         [24] 2206 	mov	dptr,#0x0064
      00078C C0 07            [24] 2207 	push	ar7
      00078E C0 06            [24] 2208 	push	ar6
      000790 C0 05            [24] 2209 	push	ar5
      000792 C0 04            [24] 2210 	push	ar4
      000794 12r00r00         [24] 2211 	lcall	_mDelaymS
      000797 D0 04            [24] 2212 	pop	ar4
      000799 D0 05            [24] 2213 	pop	ar5
      00079B D0 06            [24] 2214 	pop	ar6
      00079D D0 07            [24] 2215 	pop	ar7
                                   2216 ;	src\usbhost.c:664: if (t > 10)
      00079F ED               [12] 2217 	mov	a,r5
      0007A0 60 03            [24] 2218 	jz	00142$
                                   2219 ;	src\usbhost.c:665: return (s);
      0007A2 8F 82            [24] 2220 	mov	dpl, r7
      0007A4 22               [24] 2221 	ret
      0007A5                       2222 00142$:
                                   2223 ;	src\usbhost.c:661: for (i = 0; i < t; i++)
      0007A5 0C               [12] 2224 	inc	r4
      0007A6 80 DC            [24] 2225 	sjmp	00141$
      0007A8                       2226 00104$:
                                   2227 ;	src\usbhost.c:667: ResetRootHubPort();              // 检测到设备后,复位相应端口的USB总线
      0007A8 C0 06            [24] 2228 	push	ar6
      0007AA 12r00r58         [24] 2229 	lcall	_ResetRootHubPort
      0007AD D0 06            [24] 2230 	pop	ar6
                                   2231 ;	src\usbhost.c:668: for (i = 0, s = 0; i < 100; i++) // 等待USB设备复位后重新连接,100mS超时
      0007AF 7D 00            [12] 2232 	mov	r5,#0x00
      0007B1 7C 00            [12] 2233 	mov	r4,#0x00
      0007B3                       2234 00144$:
      0007B3 BD 64 00         [24] 2235 	cjne	r5,#0x64,00316$
      0007B6                       2236 00316$:
      0007B6 50 4E            [24] 2237 	jnc	00111$
                                   2238 ;	src\usbhost.c:670: mDelaymS(1);
      0007B8 90 00 01         [24] 2239 	mov	dptr,#0x0001
      0007BB C0 06            [24] 2240 	push	ar6
      0007BD C0 05            [24] 2241 	push	ar5
      0007BF C0 04            [24] 2242 	push	ar4
      0007C1 12r00r00         [24] 2243 	lcall	_mDelaymS
                                   2244 ;	src\usbhost.c:671: if (EnableRootHubPort() == ERR_SUCCESS) // 使能ROOT-HUB端口
      0007C4 12r00r99         [24] 2245 	lcall	_EnableRootHubPort
      0007C7 E5 82            [12] 2246 	mov	a, dpl
      0007C9 D0 04            [24] 2247 	pop	ar4
      0007CB D0 05            [24] 2248 	pop	ar5
      0007CD D0 06            [24] 2249 	pop	ar6
                                   2250 ;	src\usbhost.c:673: i = 0;
      0007CF 70 20            [24] 2251 	jnz	00108$
      0007D1 FD               [12] 2252 	mov	r5,a
                                   2253 ;	src\usbhost.c:674: s++; // 计时等待USB设备连接后稳定
      0007D2 0C               [12] 2254 	inc	r4
                                   2255 ;	src\usbhost.c:675: if (s > (20 + t))
      0007D3 8E 02            [24] 2256 	mov	ar2,r6
      0007D5 7B 00            [12] 2257 	mov	r3,#0x00
      0007D7 74 14            [12] 2258 	mov	a,#0x14
      0007D9 2A               [12] 2259 	add	a, r2
      0007DA FA               [12] 2260 	mov	r2,a
      0007DB E4               [12] 2261 	clr	a
      0007DC 3B               [12] 2262 	addc	a, r3
      0007DD FB               [12] 2263 	mov	r3,a
      0007DE 8C 00            [24] 2264 	mov	ar0,r4
      0007E0 79 00            [12] 2265 	mov	r1,#0x00
      0007E2 C3               [12] 2266 	clr	c
      0007E3 EA               [12] 2267 	mov	a,r2
      0007E4 98               [12] 2268 	subb	a,r0
      0007E5 EB               [12] 2269 	mov	a,r3
      0007E6 64 80            [12] 2270 	xrl	a,#0x80
      0007E8 89 F0            [24] 2271 	mov	b,r1
      0007EA 63 F0 80         [24] 2272 	xrl	b,#0x80
      0007ED 95 F0            [12] 2273 	subb	a,b
      0007EF 40 15            [24] 2274 	jc	00111$
                                   2275 ;	src\usbhost.c:677: break; // 已经稳定连接15mS
      0007F1                       2276 00108$:
                                   2277 ;	src\usbhost.c:680: if (i) // The device is not connected after reset
      0007F1 ED               [12] 2278 	mov	a,r5
      0007F2 60 0F            [24] 2279 	jz	00145$
                                   2280 ;	src\usbhost.c:682: DisableRootHubPort();
      0007F4 C0 06            [24] 2281 	push	ar6
      0007F6 C0 05            [24] 2282 	push	ar5
      0007F8 C0 04            [24] 2283 	push	ar4
      0007FA 12r00r00         [24] 2284 	lcall	_DisableRootHubPort
      0007FD D0 04            [24] 2285 	pop	ar4
      0007FF D0 05            [24] 2286 	pop	ar5
      000801 D0 06            [24] 2287 	pop	ar6
      000803                       2288 00145$:
                                   2289 ;	src\usbhost.c:668: for (i = 0, s = 0; i < 100; i++) // 等待USB设备复位后重新连接,100mS超时
      000803 0D               [12] 2290 	inc	r5
      000804 80 AD            [24] 2291 	sjmp	00144$
      000806                       2292 00111$:
                                   2293 ;	src\usbhost.c:689: SelectHubPort();
      000806 C0 06            [24] 2294 	push	ar6
      000808 12r00rDA         [24] 2295 	lcall	_SelectHubPort
                                   2296 ;	src\usbhost.c:696: s = CtrlGetDeviceDescr(); // Get device descriptor
      00080B 12r04r8C         [24] 2297 	lcall	_CtrlGetDeviceDescr
      00080E AF 82            [24] 2298 	mov	r7, dpl
      000810 D0 06            [24] 2299 	pop	ar6
                                   2300 ;	src\usbhost.c:697: if (s == ERR_SUCCESS)
      000812 EF               [12] 2301 	mov	a,r7
      000813 60 03            [24] 2302 	jz	00321$
      000815 02r09r92         [24] 2303 	ljmp	00139$
      000818                       2304 00321$:
                                   2305 ;	src\usbhost.c:706: ThisUsbDev.DeviceVID = (((uint16_t)((PXUSB_DEV_DESCR)Com_Buffer)->idVendorH) << 8) + ((PXUSB_DEV_DESCR)Com_Buffer)->idVendorL; // 保存VID PID信息
      000818 90r00r09         [24] 2306 	mov	dptr,#(_Com_Buffer + 0x0009)
      00081B E0               [24] 2307 	movx	a,@dptr
      00081C FC               [12] 2308 	mov	r4,a
      00081D 7D 00            [12] 2309 	mov	r5,#0x00
      00081F 90r00r08         [24] 2310 	mov	dptr,#(_Com_Buffer + 0x0008)
      000822 E0               [24] 2311 	movx	a,@dptr
      000823 7A 00            [12] 2312 	mov	r2,#0x00
      000825 2D               [12] 2313 	add	a, r5
      000826 FD               [12] 2314 	mov	r5,a
      000827 EA               [12] 2315 	mov	a,r2
      000828 3C               [12] 2316 	addc	a, r4
      000829 FC               [12] 2317 	mov	r4,a
      00082A 90r00r04         [24] 2318 	mov	dptr,#(_ThisUsbDev + 0x0004)
      00082D ED               [12] 2319 	mov	a,r5
      00082E F0               [24] 2320 	movx	@dptr,a
      00082F EC               [12] 2321 	mov	a,r4
      000830 A3               [24] 2322 	inc	dptr
      000831 F0               [24] 2323 	movx	@dptr,a
                                   2324 ;	src\usbhost.c:707: ThisUsbDev.DevicePID = (((uint16_t)((PXUSB_DEV_DESCR)Com_Buffer)->idProductH) << 8) + ((PXUSB_DEV_DESCR)Com_Buffer)->idProductL;
      000832 90r00r0B         [24] 2325 	mov	dptr,#(_Com_Buffer + 0x000b)
      000835 E0               [24] 2326 	movx	a,@dptr
      000836 FC               [12] 2327 	mov	r4,a
      000837 7D 00            [12] 2328 	mov	r5,#0x00
      000839 90r00r0A         [24] 2329 	mov	dptr,#(_Com_Buffer + 0x000a)
      00083C E0               [24] 2330 	movx	a,@dptr
      00083D 2D               [12] 2331 	add	a, r5
      00083E FD               [12] 2332 	mov	r5,a
      00083F EA               [12] 2333 	mov	a,r2
      000840 3C               [12] 2334 	addc	a, r4
      000841 FC               [12] 2335 	mov	r4,a
      000842 90r00r06         [24] 2336 	mov	dptr,#(_ThisUsbDev + 0x0006)
      000845 ED               [12] 2337 	mov	a,r5
      000846 F0               [24] 2338 	movx	@dptr,a
      000847 EC               [12] 2339 	mov	a,r4
      000848 A3               [24] 2340 	inc	dptr
      000849 F0               [24] 2341 	movx	@dptr,a
                                   2342 ;	src\usbhost.c:708: dv_cls = ((PXUSB_DEV_DESCR)Com_Buffer)->bDeviceClass;              // 设备类代码
      00084A 90r00r04         [24] 2343 	mov	dptr,#(_Com_Buffer + 0x0004)
      00084D E0               [24] 2344 	movx	a,@dptr
      00084E FD               [12] 2345 	mov	r5,a
                                   2346 ;	src\usbhost.c:709: s = CtrlSetUsbAddress(((PUSB_SETUP_REQ)SetupSetUsbAddr)->wValueL); // 设置USB设备地址,加上RootHubIndex可以保证2个HUB端口分配不同的地址
      00084F 90r00r02         [24] 2347 	mov	dptr,#(_SetupSetUsbAddr + 0x0002)
      000852 E4               [12] 2348 	clr	a
      000853 93               [24] 2349 	movc	a,@a+dptr
      000854 F5 82            [12] 2350 	mov	dpl,a
      000856 C0 06            [24] 2351 	push	ar6
      000858 C0 05            [24] 2352 	push	ar5
      00085A 12r05r15         [24] 2353 	lcall	_CtrlSetUsbAddress
      00085D AF 82            [24] 2354 	mov	r7, dpl
      00085F D0 05            [24] 2355 	pop	ar5
      000861 D0 06            [24] 2356 	pop	ar6
                                   2357 ;	src\usbhost.c:710: if (s == ERR_SUCCESS)
      000863 EF               [12] 2358 	mov	a,r7
      000864 60 03            [24] 2359 	jz	00322$
      000866 02r09r92         [24] 2360 	ljmp	00139$
      000869                       2361 00322$:
                                   2362 ;	src\usbhost.c:712: ThisUsbDev.DeviceAddress = ((PUSB_SETUP_REQ)SetupSetUsbAddr)->wValueL; // 保存USB地址
      000869 90r00r02         [24] 2363 	mov	dptr,#(_SetupSetUsbAddr + 0x0002)
      00086C E4               [12] 2364 	clr	a
      00086D 93               [24] 2365 	movc	a,@a+dptr
      00086E 90r00r01         [24] 2366 	mov	dptr,#(_ThisUsbDev + 0x0001)
      000871 F0               [24] 2367 	movx	@dptr,a
                                   2368 ;	src\usbhost.c:716: s = CtrlGetConfigDescr(); // 获取配置描述符
      000872 C0 06            [24] 2369 	push	ar6
      000874 C0 05            [24] 2370 	push	ar5
      000876 12r04rCB         [24] 2371 	lcall	_CtrlGetConfigDescr
      000879 AF 82            [24] 2372 	mov	r7, dpl
      00087B D0 05            [24] 2373 	pop	ar5
      00087D D0 06            [24] 2374 	pop	ar6
                                   2375 ;	src\usbhost.c:717: if (s == ERR_SUCCESS)
      00087F EF               [12] 2376 	mov	a,r7
      000880 60 03            [24] 2377 	jz	00323$
      000882 02r09r92         [24] 2378 	ljmp	00139$
      000885                       2379 00323$:
                                   2380 ;	src\usbhost.c:719: cfg = ((PXUSB_CFG_DESCR)Com_Buffer)->bConfigurationValue;
      000885 90r00r05         [24] 2381 	mov	dptr,#(_Com_Buffer + 0x0005)
      000888 E0               [24] 2382 	movx	a,@dptr
      000889 FC               [12] 2383 	mov	r4,a
                                   2384 ;	src\usbhost.c:720: ifc = ((PXUSB_CFG_DESCR)Com_Buffer)->bNumInterfaces;
      00088A 90r00r04         [24] 2385 	mov	dptr,#(_Com_Buffer + 0x0004)
      00088D E0               [24] 2386 	movx	a,@dptr
      00088E FB               [12] 2387 	mov	r3,a
                                   2388 ;	src\usbhost.c:729: if_cls = ((PXUSB_CFG_DESCR_LONG)Com_Buffer)->itf_descr.bInterfaceClass; // 接口类代码
      00088F 90r00r0E         [24] 2389 	mov	dptr,#(_Com_Buffer + 0x000e)
      000892 E0               [24] 2390 	movx	a,@dptr
      000893 FA               [12] 2391 	mov	r2,a
                                   2392 ;	src\usbhost.c:730: if_cls2 = Com_Buffer[41];
      000894 90r00r29         [24] 2393 	mov	dptr,#(_Com_Buffer + 0x0029)
      000897 E0               [24] 2394 	movx	a,@dptr
      000898 F9               [12] 2395 	mov	r1,a
                                   2396 ;	src\usbhost.c:732: if ((dv_cls == 0x00) && (if_cls == USB_DEV_CLASS_HID) && (((PXUSB_CFG_DESCR_LONG)Com_Buffer)->itf_descr.bInterfaceSubClass <= 0x01)) // 是HID类设备,键盘/鼠标等
      000899 ED               [12] 2397 	mov	a,r5
      00089A 60 03            [24] 2398 	jz	00324$
      00089C 02r09r7D         [24] 2399 	ljmp	00130$
      00089F                       2400 00324$:
      00089F BA 03 02         [24] 2401 	cjne	r2,#0x03,00325$
      0008A2 80 03            [24] 2402 	sjmp	00326$
      0008A4                       2403 00325$:
      0008A4 02r09r7D         [24] 2404 	ljmp	00130$
      0008A7                       2405 00326$:
      0008A7 90r00r0F         [24] 2406 	mov	dptr,#(_Com_Buffer + 0x000f)
      0008AA E0               [24] 2407 	movx	a,@dptr
      0008AB 24 FE            [12] 2408 	add	a,#0xff - 0x01
      0008AD 50 03            [24] 2409 	jnc	00327$
      0008AF 02r09r7D         [24] 2410 	ljmp	00130$
      0008B2                       2411 00327$:
                                   2412 ;	src\usbhost.c:734: s = AnalyzeHidIntEndp(Com_Buffer); // 从描述符中分析出HID中断端点的地址
      0008B2 90r00r00         [24] 2413 	mov	dptr,#_Com_Buffer
      0008B5 C0 06            [24] 2414 	push	ar6
      0008B7 C0 04            [24] 2415 	push	ar4
      0008B9 C0 03            [24] 2416 	push	ar3
      0008BB C0 01            [24] 2417 	push	ar1
      0008BD 12r05rFF         [24] 2418 	lcall	_AnalyzeHidIntEndp
      0008C0 D0 01            [24] 2419 	pop	ar1
      0008C2 D0 03            [24] 2420 	pop	ar3
      0008C4 D0 04            [24] 2421 	pop	ar4
                                   2422 ;	src\usbhost.c:740: if_cls = ((PXUSB_CFG_DESCR_LONG)Com_Buffer)->itf_descr.bInterfaceProtocol;
      0008C6 90r00r10         [24] 2423 	mov	dptr,#(_Com_Buffer + 0x0010)
      0008C9 E0               [24] 2424 	movx	a,@dptr
      0008CA FD               [12] 2425 	mov	r5,a
                                   2426 ;	src\usbhost.c:748: s = CtrlSetUsbConfig(cfg); // 设置USB设备配置
      0008CB 8C 82            [24] 2427 	mov	dpl, r4
      0008CD C0 05            [24] 2428 	push	ar5
      0008CF C0 03            [24] 2429 	push	ar3
      0008D1 C0 01            [24] 2430 	push	ar1
      0008D3 12r05r4F         [24] 2431 	lcall	_CtrlSetUsbConfig
      0008D6 AF 82            [24] 2432 	mov	r7, dpl
      0008D8 D0 01            [24] 2433 	pop	ar1
      0008DA D0 03            [24] 2434 	pop	ar3
      0008DC D0 05            [24] 2435 	pop	ar5
      0008DE D0 06            [24] 2436 	pop	ar6
                                   2437 ;	src\usbhost.c:749: if (s == ERR_SUCCESS)
      0008E0 EF               [12] 2438 	mov	a,r7
      0008E1 60 03            [24] 2439 	jz	00328$
      0008E3 02r09r92         [24] 2440 	ljmp	00139$
      0008E6                       2441 00328$:
                                   2442 ;	src\usbhost.c:754: for (dv_cls = 0; dv_cls < ifc; dv_cls++) // ifc = nbinterfaces
      0008E6 7A 00            [12] 2443 	mov	r2,#0x00
      0008E8                       2444 00147$:
      0008E8 C3               [12] 2445 	clr	c
      0008E9 EA               [12] 2446 	mov	a,r2
      0008EA 9B               [12] 2447 	subb	a,r3
      0008EB 50 1C            [24] 2448 	jnc	00112$
                                   2449 ;	src\usbhost.c:756: s = CtrlGetHIDDeviceReport(dv_cls); // 获取报表描述符
      0008ED 8A 82            [24] 2450 	mov	dpl, r2
      0008EF C0 06            [24] 2451 	push	ar6
      0008F1 C0 05            [24] 2452 	push	ar5
      0008F3 C0 03            [24] 2453 	push	ar3
      0008F5 C0 02            [24] 2454 	push	ar2
      0008F7 C0 01            [24] 2455 	push	ar1
      0008F9 12r05rA9         [24] 2456 	lcall	_CtrlGetHIDDeviceReport
      0008FC D0 01            [24] 2457 	pop	ar1
      0008FE D0 02            [24] 2458 	pop	ar2
      000900 D0 03            [24] 2459 	pop	ar3
      000902 D0 05            [24] 2460 	pop	ar5
      000904 D0 06            [24] 2461 	pop	ar6
                                   2462 ;	src\usbhost.c:754: for (dv_cls = 0; dv_cls < ifc; dv_cls++) // ifc = nbinterfaces
      000906 0A               [12] 2463 	inc	r2
      000907 80 DF            [24] 2464 	sjmp	00147$
      000909                       2465 00112$:
                                   2466 ;	src\usbhost.c:770: ThisUsbDev.DeviceStatus = ROOT_DEV_SUCCESS;
      000909 90r00r00         [24] 2467 	mov	dptr,#_ThisUsbDev
      00090C 74 03            [12] 2468 	mov	a,#0x03
      00090E F0               [24] 2469 	movx	@dptr,a
                                   2470 ;	src\usbhost.c:771: if (if_cls == 1)
      00090F BD 01 30         [24] 2471 	cjne	r5,#0x01,00125$
                                   2472 ;	src\usbhost.c:773: ThisUsbDev.DeviceType = DEV_TYPE_KEYBOARD;
      000912 90r00r03         [24] 2473 	mov	dptr,#(_ThisUsbDev + 0x0003)
      000915 74 23            [12] 2474 	mov	a,#0x23
      000917 F0               [24] 2475 	movx	@dptr,a
                                   2476 ;	src\usbhost.c:775: if (ifc > 1)
      000918 EB               [12] 2477 	mov	a,r3
      000919 24 FE            [12] 2478 	add	a,#0xff - 0x01
      00091B 50 1B            [24] 2479 	jnc	00116$
                                   2480 ;	src\usbhost.c:780: ThisUsbDev.DeviceType = USB_DEV_CLASS_HID; // 复合HID设备
      00091D 90r00r03         [24] 2481 	mov	dptr,#(_ThisUsbDev + 0x0003)
      000920 74 03            [12] 2482 	mov	a,#0x03
      000922 F0               [24] 2483 	movx	@dptr,a
                                   2484 ;	src\usbhost.c:781: if (if_cls2 == 2)
      000923 B9 02 12         [24] 2485 	cjne	r1,#0x02,00116$
                                   2486 ;	src\usbhost.c:783: ThisUsbDev.DeviceType = DEV_TYPE_MOUSE2;
      000926 90r00r03         [24] 2487 	mov	dptr,#(_ThisUsbDev + 0x0003)
      000929 74 43            [12] 2488 	mov	a,#0x43
      00092B F0               [24] 2489 	movx	@dptr,a
                                   2490 ;	src\usbhost.c:786: SetBootProto(0); // Keyboard proto
      00092C 75 82 00         [24] 2491 	mov	dpl, #0x00
      00092F 12r09rDC         [24] 2492 	lcall	_SetBootProto
                                   2493 ;	src\usbhost.c:787: SetBootProto(1);
      000932 75 82 01         [24] 2494 	mov	dpl, #0x01
      000935 12r09rDC         [24] 2495 	lcall	_SetBootProto
      000938                       2496 00116$:
                                   2497 ;	src\usbhost.c:796: SetUsbSpeed(1); // 默认为全速
      000938 75 82 01         [24] 2498 	mov	dpl, #0x01
      00093B 12r00r49         [24] 2499 	lcall	_SetUsbSpeed
                                   2500 ;	src\usbhost.c:798: return (ERR_SUCCESS);
      00093E 75 82 00         [24] 2501 	mov	dpl, #0x00
      000941 22               [24] 2502 	ret
      000942                       2503 00125$:
                                   2504 ;	src\usbhost.c:800: else if (if_cls == 2)
      000942 BD 02 16         [24] 2505 	cjne	r5,#0x02,00122$
                                   2506 ;	src\usbhost.c:802: ThisUsbDev.DeviceType = DEV_TYPE_MOUSE;
      000945 90r00r03         [24] 2507 	mov	dptr,#(_ThisUsbDev + 0x0003)
      000948 74 33            [12] 2508 	mov	a,#0x33
      00094A F0               [24] 2509 	movx	@dptr,a
                                   2510 ;	src\usbhost.c:811: SetBootProto(0);
      00094B 75 82 00         [24] 2511 	mov	dpl, #0x00
      00094E 12r09rDC         [24] 2512 	lcall	_SetBootProto
                                   2513 ;	src\usbhost.c:815: SetUsbSpeed(1); // The default is full speed
      000951 75 82 01         [24] 2514 	mov	dpl, #0x01
      000954 12r00r49         [24] 2515 	lcall	_SetUsbSpeed
                                   2516 ;	src\usbhost.c:817: return (ERR_SUCCESS);
      000957 75 82 00         [24] 2517 	mov	dpl, #0x00
      00095A 22               [24] 2518 	ret
      00095B                       2519 00122$:
                                   2520 ;	src\usbhost.c:819: else if (if_cls == 0)
      00095B ED               [12] 2521 	mov	a,r5
      00095C 70 1B            [24] 2522 	jnz	00126$
                                   2523 ;	src\usbhost.c:821: ThisUsbDev.DeviceType = DEV_TYPE_JOYSTICK;
      00095E 90r00r03         [24] 2524 	mov	dptr,#(_ThisUsbDev + 0x0003)
      000961 74 53            [12] 2525 	mov	a,#0x53
      000963 F0               [24] 2526 	movx	@dptr,a
                                   2527 ;	src\usbhost.c:823: if (ifc > 1)
      000964 EB               [12] 2528 	mov	a,r3
      000965 24 FE            [12] 2529 	add	a,#0xff - 0x01
      000967 50 06            [24] 2530 	jnc	00118$
                                   2531 ;	src\usbhost.c:828: ThisUsbDev.DeviceType = USB_DEV_CLASS_HID; // Composite HID equipment
      000969 90r00r03         [24] 2532 	mov	dptr,#(_ThisUsbDev + 0x0003)
      00096C 74 03            [12] 2533 	mov	a,#0x03
      00096E F0               [24] 2534 	movx	@dptr,a
      00096F                       2535 00118$:
                                   2536 ;	src\usbhost.c:833: SetUsbSpeed(1); // The default is full speed
      00096F 75 82 01         [24] 2537 	mov	dpl, #0x01
      000972 12r00r49         [24] 2538 	lcall	_SetUsbSpeed
                                   2539 ;	src\usbhost.c:835: return (ERR_SUCCESS);
      000975 75 82 00         [24] 2540 	mov	dpl, #0x00
      000978 22               [24] 2541 	ret
      000979                       2542 00126$:
                                   2543 ;	src\usbhost.c:837: s = ERR_USB_UNSUPPORT;
      000979 7F FB            [12] 2544 	mov	r7,#0xfb
      00097B 80 15            [24] 2545 	sjmp	00139$
      00097D                       2546 00130$:
                                   2547 ;	src\usbhost.c:853: AnalyzeBulkEndp(Com_Buffer); // 分析出批量端点
      00097D 90r00r00         [24] 2548 	mov	dptr,#_Com_Buffer
      000980 C0 06            [24] 2549 	push	ar6
      000982 C0 04            [24] 2550 	push	ar4
      000984 12r06r9D         [24] 2551 	lcall	_AnalyzeBulkEndp
      000987 D0 04            [24] 2552 	pop	ar4
                                   2553 ;	src\usbhost.c:861: s = CtrlSetUsbConfig(cfg); // 设置USB设备配置
      000989 8C 82            [24] 2554 	mov	dpl, r4
      00098B 12r05r4F         [24] 2555 	lcall	_CtrlSetUsbConfig
      00098E AF 82            [24] 2556 	mov	r7, dpl
      000990 D0 06            [24] 2557 	pop	ar6
                                   2558 ;	src\usbhost.c:862: if (s == ERR_SUCCESS)
      000992                       2559 00139$:
                                   2560 ;	src\usbhost.c:879: ThisUsbDev.DeviceStatus = ROOT_DEV_FAILED;
      000992 90r00r00         [24] 2561 	mov	dptr,#_ThisUsbDev
      000995 74 02            [12] 2562 	mov	a,#0x02
      000997 F0               [24] 2563 	movx	@dptr,a
                                   2564 ;	src\usbhost.c:880: SetUsbSpeed(1); // 默认为全速
      000998 75 82 01         [24] 2565 	mov	dpl, #0x01
      00099B C0 07            [24] 2566 	push	ar7
      00099D C0 06            [24] 2567 	push	ar6
      00099F 12r00r49         [24] 2568 	lcall	_SetUsbSpeed
      0009A2 D0 06            [24] 2569 	pop	ar6
      0009A4 D0 07            [24] 2570 	pop	ar7
                                   2571 ;	src\usbhost.c:881: t++;
      0009A6 0E               [12] 2572 	inc	r6
                                   2573 ;	src\usbhost.c:882: goto USBDevEnum;
                                   2574 ;	src\usbhost.c:883: }
      0009A7 02r07r7B         [24] 2575 	ljmp	00153$
                                   2576 ;------------------------------------------------------------
                                   2577 ;Allocation info for local variables in function 'EnumAllRootDevice'
                                   2578 ;------------------------------------------------------------
                                   2579 ;s                         Allocated to registers r6 
                                   2580 ;------------------------------------------------------------
                                   2581 ;	src\usbhost.c:891: uint8_t EnumAllRootDevice(void)
                                   2582 ;	-----------------------------------------
                                   2583 ;	 function EnumAllRootDevice
                                   2584 ;	-----------------------------------------
      0009AA                       2585 _EnumAllRootDevice:
                                   2586 ;	src\usbhost.c:897: if (ThisUsbDev.DeviceStatus == ROOT_DEV_CONNECTED) // The device has just been plugged in and has not been initialized
      0009AA 90r00r00         [24] 2587 	mov	dptr,#_ThisUsbDev
      0009AD E0               [24] 2588 	movx	a,@dptr
      0009AE FF               [12] 2589 	mov	r7,a
      0009AF BF 01 0B         [24] 2590 	cjne	r7,#0x01,00104$
                                   2591 ;	src\usbhost.c:899: s = InitRootDevice(); // Initialize/enumerate the USB devices of the specified HUB port
      0009B2 12r07r77         [24] 2592 	lcall	_InitRootDevice
                                   2593 ;	src\usbhost.c:900: if (s != ERR_SUCCESS)
      0009B5 E5 82            [12] 2594 	mov	a,dpl
      0009B7 FE               [12] 2595 	mov	r6,a
      0009B8 60 03            [24] 2596 	jz	00104$
                                   2597 ;	src\usbhost.c:902: return (s);
      0009BA 8E 82            [24] 2598 	mov	dpl, r6
      0009BC 22               [24] 2599 	ret
      0009BD                       2600 00104$:
                                   2601 ;	src\usbhost.c:905: return (ERR_SUCCESS);
      0009BD 75 82 00         [24] 2602 	mov	dpl, #0x00
                                   2603 ;	src\usbhost.c:906: }
      0009C0 22               [24] 2604 	ret
                                   2605 ;------------------------------------------------------------
                                   2606 ;Allocation info for local variables in function 'SearchTypeDevice'
                                   2607 ;------------------------------------------------------------
                                   2608 ;type                      Allocated to registers r7 
                                   2609 ;RootHubIndex              Allocated to registers 
                                   2610 ;------------------------------------------------------------
                                   2611 ;	src\usbhost.c:916: uint16_t SearchTypeDevice(uint8_t type)
                                   2612 ;	-----------------------------------------
                                   2613 ;	 function SearchTypeDevice
                                   2614 ;	-----------------------------------------
      0009C1                       2615 _SearchTypeDevice:
      0009C1 AF 82            [24] 2616 	mov	r7, dpl
                                   2617 ;	src\usbhost.c:922: if ((ThisUsbDev.DeviceType == type) && (ThisUsbDev.DeviceStatus >= ROOT_DEV_SUCCESS))
      0009C3 90r00r03         [24] 2618 	mov	dptr,#(_ThisUsbDev + 0x0003)
      0009C6 E0               [24] 2619 	movx	a,@dptr
      0009C7 B5 07 0E         [24] 2620 	cjne	a,ar7,00102$
      0009CA 90r00r00         [24] 2621 	mov	dptr,#_ThisUsbDev
      0009CD E0               [24] 2622 	movx	a,@dptr
      0009CE FF               [12] 2623 	mov	r7,a
      0009CF BF 03 00         [24] 2624 	cjne	r7,#0x03,00120$
      0009D2                       2625 00120$:
      0009D2 40 04            [24] 2626 	jc	00102$
                                   2627 ;	src\usbhost.c:924: return ((uint16_t)RootHubIndex << 8); // 类型匹配且枚举成功,在ROOT-HUB端口上
      0009D4 90 00 00         [24] 2628 	mov	dptr,#0x0000
      0009D7 22               [24] 2629 	ret
      0009D8                       2630 00102$:
                                   2631 ;	src\usbhost.c:927: return (0xFFFF);
      0009D8 90 FF FF         [24] 2632 	mov	dptr,#0xffff
                                   2633 ;	src\usbhost.c:928: }
      0009DB 22               [24] 2634 	ret
                                   2635 ;------------------------------------------------------------
                                   2636 ;Allocation info for local variables in function 'SetBootProto'
                                   2637 ;------------------------------------------------------------
                                   2638 ;intf                      Allocated to registers r7 
                                   2639 ;get                       Allocated with name '_SetBootProto_get_10000_220'
                                   2640 ;set                       Allocated with name '_SetBootProto_set_10000_220'
                                   2641 ;report                    Allocated with name '_SetBootProto_report_10000_220'
                                   2642 ;len                       Allocated with name '_SetBootProto_len_10000_220'
                                   2643 ;s                         Allocated to registers r6 
                                   2644 ;------------------------------------------------------------
                                   2645 ;	src\usbhost.c:930: uint8_t SetBootProto(uint8_t intf)
                                   2646 ;	-----------------------------------------
                                   2647 ;	 function SetBootProto
                                   2648 ;	-----------------------------------------
      0009DC                       2649 _SetBootProto:
      0009DC AF 82            [24] 2650 	mov	r7, dpl
                                   2651 ;	src\usbhost.c:932: uint8_t get[] = {0xA1, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00};
      0009DE 75*15 A1         [24] 2652 	mov	_SetBootProto_get_10000_220,#0xa1
      0009E1 75*16 03         [24] 2653 	mov	(_SetBootProto_get_10000_220 + 0x0001),#0x03
      0009E4 75*17 00         [24] 2654 	mov	(_SetBootProto_get_10000_220 + 0x0002),#0x00
      0009E7 75*18 00         [24] 2655 	mov	(_SetBootProto_get_10000_220 + 0x0003),#0x00
      0009EA 75*19 00         [24] 2656 	mov	(_SetBootProto_get_10000_220 + 0x0004),#0x00
      0009ED 75*1A 00         [24] 2657 	mov	(_SetBootProto_get_10000_220 + 0x0005),#0x00
      0009F0 75*1B 01         [24] 2658 	mov	(_SetBootProto_get_10000_220 + 0x0006),#0x01
      0009F3 75*1C 00         [24] 2659 	mov	(_SetBootProto_get_10000_220 + 0x0007),#0x00
                                   2660 ;	src\usbhost.c:933: uint8_t set[] = {0x21, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
      0009F6 75*1D 21         [24] 2661 	mov	_SetBootProto_set_10000_220,#0x21
      0009F9 75*1E 0B         [24] 2662 	mov	(_SetBootProto_set_10000_220 + 0x0001),#0x0b
      0009FC 75*1F 00         [24] 2663 	mov	(_SetBootProto_set_10000_220 + 0x0002),#0x00
      0009FF 75*20 00         [24] 2664 	mov	(_SetBootProto_set_10000_220 + 0x0003),#0x00
      000A02 75*21 00         [24] 2665 	mov	(_SetBootProto_set_10000_220 + 0x0004),#0x00
      000A05 75*22 00         [24] 2666 	mov	(_SetBootProto_set_10000_220 + 0x0005),#0x00
      000A08 75*23 00         [24] 2667 	mov	(_SetBootProto_set_10000_220 + 0x0006),#0x00
      000A0B 75*24 00         [24] 2668 	mov	(_SetBootProto_set_10000_220 + 0x0007),#0x00
                                   2669 ;	src\usbhost.c:934: uint8_t report[] = {0x21, 0x09, 0x00, 0x02, 0x00, 0x00, 0x01, 0x00};
      000A0E 75*25 21         [24] 2670 	mov	_SetBootProto_report_10000_220,#0x21
      000A11 75*26 09         [24] 2671 	mov	(_SetBootProto_report_10000_220 + 0x0001),#0x09
      000A14 75*27 00         [24] 2672 	mov	(_SetBootProto_report_10000_220 + 0x0002),#0x00
      000A17 75*28 02         [24] 2673 	mov	(_SetBootProto_report_10000_220 + 0x0003),#0x02
      000A1A 75*29 00         [24] 2674 	mov	(_SetBootProto_report_10000_220 + 0x0004),#0x00
      000A1D 75*2A 00         [24] 2675 	mov	(_SetBootProto_report_10000_220 + 0x0005),#0x00
      000A20 75*2B 01         [24] 2676 	mov	(_SetBootProto_report_10000_220 + 0x0006),#0x01
      000A23 75*2C 00         [24] 2677 	mov	(_SetBootProto_report_10000_220 + 0x0007),#0x00
                                   2678 ;	src\usbhost.c:938: for (s = 0; s != sizeof(get); s++)
      000A26 7E 00            [12] 2679 	mov	r6,#0x00
      000A28                       2680 00109$:
                                   2681 ;	src\usbhost.c:940: ((__xdata uint8_t *)pSetupReq)[s] = get[s];
      000A28 EE               [12] 2682 	mov	a,r6
      000A29 24r00            [12] 2683 	add	a, #_TxBuffer
      000A2B F5 82            [12] 2684 	mov	dpl,a
      000A2D E4               [12] 2685 	clr	a
      000A2E 34s00            [12] 2686 	addc	a, #(_TxBuffer >> 8)
      000A30 F5 83            [12] 2687 	mov	dph,a
      000A32 EE               [12] 2688 	mov	a,r6
      000A33 24r15            [12] 2689 	add	a, #_SetBootProto_get_10000_220
      000A35 F9               [12] 2690 	mov	r1,a
      000A36 E7               [12] 2691 	mov	a,@r1
      000A37 F0               [24] 2692 	movx	@dptr,a
                                   2693 ;	src\usbhost.c:938: for (s = 0; s != sizeof(get); s++)
      000A38 0E               [12] 2694 	inc	r6
      000A39 BE 08 EC         [24] 2695 	cjne	r6,#0x08,00109$
                                   2696 ;	src\usbhost.c:942: ((__xdata uint8_t *)pSetupReq)[4] = intf;
      000A3C 90r00r04         [24] 2697 	mov	dptr,#(_TxBuffer + 0x0004)
      000A3F EF               [12] 2698 	mov	a,r7
      000A40 F0               [24] 2699 	movx	@dptr,a
                                   2700 ;	src\usbhost.c:943: s = HostCtrlTransfer(Com_Buffer, &len);
      000A41 75*05r2D         [24] 2701 	mov	_HostCtrlTransfer_PARM_2,#_SetBootProto_len_10000_220
      000A44 75*06 00         [24] 2702 	mov	(_HostCtrlTransfer_PARM_2 + 1),#0x00
      000A47 75*07 40         [24] 2703 	mov	(_HostCtrlTransfer_PARM_2 + 2),#0x40
      000A4A 90r00r00         [24] 2704 	mov	dptr,#_Com_Buffer
      000A4D C0 07            [24] 2705 	push	ar7
      000A4F 12r02r31         [24] 2706 	lcall	_HostCtrlTransfer
      000A52 AE 82            [24] 2707 	mov	r6, dpl
      000A54 D0 07            [24] 2708 	pop	ar7
                                   2709 ;	src\usbhost.c:945: if (s != ERR_SUCCESS)
      000A56 EE               [12] 2710 	mov	a,r6
      000A57 60 03            [24] 2711 	jz	00103$
                                   2712 ;	src\usbhost.c:947: return (s);
      000A59 8E 82            [24] 2713 	mov	dpl, r6
      000A5B 22               [24] 2714 	ret
      000A5C                       2715 00103$:
                                   2716 ;	src\usbhost.c:956: if (Com_Buffer[0] != 0)
      000A5C 90r00r00         [24] 2717 	mov	dptr,#_Com_Buffer
      000A5F E0               [24] 2718 	movx	a,@dptr
      000A60 60 2C            [24] 2719 	jz	00106$
                                   2720 ;	src\usbhost.c:958: for (s = 0; s != sizeof(set); s++)
      000A62 7D 00            [12] 2721 	mov	r5,#0x00
      000A64                       2722 00111$:
                                   2723 ;	src\usbhost.c:960: ((__xdata uint8_t *)pSetupReq)[s] = set[s];
      000A64 ED               [12] 2724 	mov	a,r5
      000A65 24r00            [12] 2725 	add	a, #_TxBuffer
      000A67 F5 82            [12] 2726 	mov	dpl,a
      000A69 E4               [12] 2727 	clr	a
      000A6A 34s00            [12] 2728 	addc	a, #(_TxBuffer >> 8)
      000A6C F5 83            [12] 2729 	mov	dph,a
      000A6E ED               [12] 2730 	mov	a,r5
      000A6F 24r1D            [12] 2731 	add	a, #_SetBootProto_set_10000_220
      000A71 F9               [12] 2732 	mov	r1,a
      000A72 E7               [12] 2733 	mov	a,@r1
      000A73 F0               [24] 2734 	movx	@dptr,a
                                   2735 ;	src\usbhost.c:958: for (s = 0; s != sizeof(set); s++)
      000A74 0D               [12] 2736 	inc	r5
      000A75 BD 08 EC         [24] 2737 	cjne	r5,#0x08,00111$
                                   2738 ;	src\usbhost.c:962: ((__xdata uint8_t *)pSetupReq)[4] = intf;
      000A78 90r00r04         [24] 2739 	mov	dptr,#(_TxBuffer + 0x0004)
      000A7B EF               [12] 2740 	mov	a,r7
      000A7C F0               [24] 2741 	movx	@dptr,a
                                   2742 ;	src\usbhost.c:963: s = HostCtrlTransfer(Com_Buffer, &len);
      000A7D 75*05r2D         [24] 2743 	mov	_HostCtrlTransfer_PARM_2,#_SetBootProto_len_10000_220
      000A80 75*06 00         [24] 2744 	mov	(_HostCtrlTransfer_PARM_2 + 1),#0x00
      000A83 75*07 40         [24] 2745 	mov	(_HostCtrlTransfer_PARM_2 + 2),#0x40
      000A86 90r00r00         [24] 2746 	mov	dptr,#_Com_Buffer
      000A89 12r02r31         [24] 2747 	lcall	_HostCtrlTransfer
      000A8C AE 82            [24] 2748 	mov	r6, dpl
      000A8E                       2749 00106$:
                                   2750 ;	src\usbhost.c:984: if (s != ERR_SUCCESS)
      000A8E EE               [12] 2751 	mov	a,r6
      000A8F 60 03            [24] 2752 	jz	00108$
                                   2753 ;	src\usbhost.c:986: return (s);
      000A91 8E 82            [24] 2754 	mov	dpl, r6
      000A93 22               [24] 2755 	ret
      000A94                       2756 00108$:
                                   2757 ;	src\usbhost.c:988: return (ERR_SUCCESS);
      000A94 75 82 00         [24] 2758 	mov	dpl, #0x00
                                   2759 ;	src\usbhost.c:989: }
      000A97 22               [24] 2760 	ret
                                   2761 ;------------------------------------------------------------
                                   2762 ;Allocation info for local variables in function 'InitUSB_Host'
                                   2763 ;------------------------------------------------------------
                                   2764 ;i                         Allocated to registers r7 
                                   2765 ;------------------------------------------------------------
                                   2766 ;	src\usbhost.c:998: void InitUSB_Host(void)
                                   2767 ;	-----------------------------------------
                                   2768 ;	 function InitUSB_Host
                                   2769 ;	-----------------------------------------
      000A98                       2770 _InitUSB_Host:
                                   2771 ;	src\usbhost.c:1001: IE_USB = 0;
                                   2772 ;	assignBit
      000A98 C2 EA            [12] 2773 	clr	_IE_USB
                                   2774 ;	src\usbhost.c:1004: USB_CTRL = bUC_HOST_MODE;  // 先设定模式
      000A9A 75 E2 80         [24] 2775 	mov	_USB_CTRL,#0x80
                                   2776 ;	src\usbhost.c:1005: UHOST_CTRL &= ~bUH_PD_DIS; // 启用主机下拉
      000A9D 53 D1 7F         [24] 2777 	anl	_UDEV_CTRL,#0x7f
                                   2778 ;	src\usbhost.c:1006: USB_DEV_AD = 0x00;
      000AA0 75 E3 00         [24] 2779 	mov	_USB_DEV_AD,#0x00
                                   2780 ;	src\usbhost.c:1007: UH_EP_MOD = bUH_EP_TX_EN | bUH_EP_RX_EN;
      000AA3 75 EB 48         [24] 2781 	mov	_UEP2_3_MOD,#0x48
                                   2782 ;	src\usbhost.c:1008: UH_RX_DMA = (uint16_t)RxBuffer;
      000AA6 7Er00            [12] 2783 	mov	r6,#_RxBuffer
      000AA8 7Fs00            [12] 2784 	mov	r7,#(_RxBuffer >> 8)
      000AAA 8E E4            [24] 2785 	mov	((_UEP2_DMA >> 0) & 0xFF),r6
      000AAC 8F E5            [24] 2786 	mov	((_UEP2_DMA >> 8) & 0xFF),r7
                                   2787 ;	src\usbhost.c:1009: UH_TX_DMA = (uint16_t)TxBuffer;
      000AAE 7Er00            [12] 2788 	mov	r6,#_TxBuffer
      000AB0 7Fs00            [12] 2789 	mov	r7,#(_TxBuffer >> 8)
      000AB2 8E E6            [24] 2790 	mov	((_UEP3_DMA >> 0) & 0xFF),r6
      000AB4 8F E7            [24] 2791 	mov	((_UEP3_DMA >> 8) & 0xFF),r7
                                   2792 ;	src\usbhost.c:1010: UH_RX_CTRL = 0x00;
      000AB6 75 D4 00         [24] 2793 	mov	_UEP2_CTRL,#0x00
                                   2794 ;	src\usbhost.c:1011: UH_TX_CTRL = 0x00;
      000AB9 75 D6 00         [24] 2795 	mov	_UEP3_CTRL,#0x00
                                   2796 ;	src\usbhost.c:1012: USB_CTRL = bUC_HOST_MODE | bUC_INT_BUSY; // | bUC_DMA_EN;                     // 启动USB主机及DMA,在中断标志未清除前自动暂停
      000ABC 75 E2 88         [24] 2797 	mov	_USB_CTRL,#0x88
                                   2798 ;	src\usbhost.c:1016: USB_INT_FG = 0xFF;                       // 清中断标志
      000ABF 75 D8 FF         [24] 2799 	mov	_USB_INT_FG,#0xff
                                   2800 ;	src\usbhost.c:1017: for (i = 0; i != 2; i++)
      000AC2 7F 00            [12] 2801 	mov	r7,#0x00
      000AC4                       2802 00102$:
                                   2803 ;	src\usbhost.c:1019: DisableRootHubPort(); // 清空
      000AC4 C0 07            [24] 2804 	push	ar7
      000AC6 12r00r00         [24] 2805 	lcall	_DisableRootHubPort
      000AC9 D0 07            [24] 2806 	pop	ar7
                                   2807 ;	src\usbhost.c:1017: for (i = 0; i != 2; i++)
      000ACB 0F               [12] 2808 	inc	r7
      000ACC BF 02 F5         [24] 2809 	cjne	r7,#0x02,00102$
                                   2810 ;	src\usbhost.c:1021: USB_INT_EN = bUIE_TRANSFER | bUIE_DETECT;
      000ACF 75 E1 03         [24] 2811 	mov	_USB_INT_EN,#0x03
                                   2812 ;	src\usbhost.c:1023: }
      000AD2 22               [24] 2813 	ret
                                   2814 	.area CSEG    (CODE)
                                   2815 	.area CONST   (CODE)
                                   2816 	.area XINIT   (CODE)
                                   2817 	.area CABS    (ABS,CODE)
